use стд::прелюдия::*;
use стд::коллекции::Вектор;
use std::num::{IntErrorKind};
use лексика::*;
use диагностика::*;
use super::Результат;

#[derive(Clone)]
pub struct Переменная {
    pub имя: Лексема,
    pub тип: Выражение,
}

impl Переменная {
    pub fn разобрать(лекс: &mut Лексер) -> Результат<Переменная> {
        let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
        let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::Двоеточие])?;
        let тип = Выражение::разобрать(лекс)?;
        let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
        Хорош(Переменная{имя, тип})
    }
}

#[derive(Debug, Clone)]
pub enum ВидБинопа {
    Меньше,
    Больше,
    МеньшеРавно,
    БольшеРавно,
    Сложение,
    Вычитание,
    Умножение,
    Деление,
    Остаток,
    Или,
    И,
    Либо,
    Равно,
    НеРавно,
    Как,
    Поле,
    ЛевоеБитовоеСмещение,
    ПравоеБитовоеСмещение,
}

impl ВидБинопа {
    const МАКС_ПРИОРИТЕТ: usize = 7;

    fn приоритет(&self) -> usize {
        use self::ВидБинопа::*;
        match self {
            Или | Либо                                          => Self::МАКС_ПРИОРИТЕТ - 7,
            И                                                   => Self::МАКС_ПРИОРИТЕТ - 6,
            Меньше | Больше | МеньшеРавно | БольшеРавно | Равно | НеРавно => Self::МАКС_ПРИОРИТЕТ - 5,
            Сложение | Вычитание                                => Self::МАКС_ПРИОРИТЕТ - 4,
            Умножение | Деление | Остаток                       => Self::МАКС_ПРИОРИТЕТ - 3,
            // СДЕЛАТЬ: какой приоритет лучше всего для битовых смещений?
            ЛевоеБитовоеСмещение | ПравоеБитовоеСмещение        => Self::МАКС_ПРИОРИТЕТ - 2,
            Как                                                 => Self::МАКС_ПРИОРИТЕТ - 1,
            Поле                                                => Self::МАКС_ПРИОРИТЕТ,
        }
    }

    fn по_виду_лексемы(вид: &ВидЛексемы) -> Опция<ВидБинопа> {
        match вид {
            ВидЛексемы::Равно           => Некий(ВидБинопа::Равно),
            ВидЛексемы::Меньше          => Некий(ВидБинопа::Меньше),
            ВидЛексемы::Больше          => Некий(ВидБинопа::Больше),
            ВидЛексемы::МеньшеРавно     => Некий(ВидБинопа::МеньшеРавно),
            ВидЛексемы::БольшеРавно     => Некий(ВидБинопа::БольшеРавно),
            ВидЛексемы::НеРавно         => Некий(ВидБинопа::НеРавно),
            ВидЛексемы::Плюс            => Некий(ВидБинопа::Сложение),
            ВидЛексемы::Минус           => Некий(ВидБинопа::Вычитание),
            ВидЛексемы::Звёздочка       => Некий(ВидБинопа::Умножение),
            ВидЛексемы::ПрямаяНаклонная => Некий(ВидБинопа::Деление),
            ВидЛексемы::КлючОст         => Некий(ВидБинопа::Остаток),
            ВидЛексемы::КлючКак         => Некий(ВидБинопа::Как),
            ВидЛексемы::КлючИли         => Некий(ВидБинопа::Или),
            ВидЛексемы::КлючИ           => Некий(ВидБинопа::И),
            ВидЛексемы::КлючЛибо        => Некий(ВидБинопа::Либо),
            ВидЛексемы::Точка           => Некий(ВидБинопа::Поле),
            ВидЛексемы::КлючЛбс         => Некий(ВидБинопа::ЛевоеБитовоеСмещение),
            ВидЛексемы::КлючПбс         => Некий(ВидБинопа::ПравоеБитовоеСмещение),
            _                           => Нету
        }
    }
}

#[derive(Debug, Clone)]
pub struct Аргументы {
    pub ключ: Лексема,
    pub выражения: Вектор<Выражение>,
}

#[derive(Debug, Clone)]
pub enum Выражение {
    ЦелЧисло(Лексема, i64),
    НатЧисло(Лексема, u64),
    ВещЧисло(Лексема, f32),
    Лог(Лексема, bool),
    Строка(Лексема),
    Идент(Лексема),
    ЦепочкаВызовов{имя: Лексема, цепочка_аргументов: Вектор<Аргументы>},
    УнарныйМинус {
        ключ: Лексема,
        выражение: Box<Выражение>,
    },
    Биноп {
        ключ: Лексема,
        вид: ВидБинопа,
        левое: Box<Выражение>,
        правое: Box<Выражение>,
    },
    Отрицание {
        ключ: Лексема,
        выражение: Box<Выражение>,
    }
}

impl Выражение {
    pub fn лок(&self) -> &Лок {
        match self {
            Выражение::ЦелЧисло(лексема, _) |
            Выражение::НатЧисло(лексема, _) |
            Выражение::ВещЧисло(лексема, _) |
            Выражение::Лог(лексема, _) |
            Выражение::Строка(лексема) |
            Выражение::Идент(лексема) => &лексема.лок,
            Выражение::Биноп{ключ, ..} => &ключ.лок,
            Выражение::ЦепочкаВызовов{имя, ..} => &имя.лок,
            Выражение::Отрицание{ключ, ..} => &ключ.лок,
            Выражение::УнарныйМинус{ключ, ..} => &ключ.лок,
        }
    }

    fn разобрать_первичное(лекс: &mut Лексер) -> Результат<Выражение> {
        let лексема = лекс.вытащить_лексему_вида(&[
            ВидЛексемы::ЦелЧисло,
            ВидЛексемы::ЦелШестЧисло,
            ВидЛексемы::ВещЧисло,
            ВидЛексемы::Идент,
            ВидЛексемы::Строка,
            ВидЛексемы::ОткрытаяСкобка,
            ВидЛексемы::Не,
            ВидЛексемы::КлючИстина,
            ВидЛексемы::КлючЛожь,
            ВидЛексемы::Минус,
        ])?;
        match лексема.вид {
            ВидЛексемы::ЦелШестЧисло => {
                if лексема.текст.len() == 0 {
                    диагностика!(&лексема.лок, "ОШИБКА", "Нет цифр для шестнадцатеричного литерала");
                    return Ошиб(());
                }

                let mut число: i64 = 0;
                for цифра in лексема.текст.chars().map(|знак| шестнадцатеричная_цифра(&знак).expect("Все шестнадцатеричные цифры должны быть проверены на этапе лексического анализа")) {
                    число = число*16 + цифра;
                }
                if лекс.подсмотреть_лексему()?.вид == ВидЛексемы::Идент {
                    if лекс.подсмотреть_лексему()?.текст == "нат" {
                        let _ = лекс.вытащить_лексему()?;
                        return Хорош(Выражение::НатЧисло(лексема, число as u64));
                    }
                }
                Хорош(Выражение::ЦелЧисло(лексема, число as i64))
            }
            ВидЛексемы::ЦелЧисло => {
                let число: u64 = match лексема.текст.parse() {
                    Хорош(число) => число,
                    Ошиб(ошибка) => match ошибка.kind() {
                        IntErrorKind::PosOverflow => {
                            диагностика!(&лексема.лок, "ОШИБКА", "Слишком большое целое");
                            return Ошиб(());
                        }
                        IntErrorKind::Empty => unreachable!(),
                        IntErrorKind::InvalidDigit => unreachable!(),
                        IntErrorKind::NegOverflow => unreachable!(),
                        IntErrorKind::Zero => unreachable!(),
                        _ => {
                            диагностика!(&лексема.лок, "ОШИБКА", "Некорректное целое число");
                            return Ошиб(());
                        }
                    }
                };
                if лекс.подсмотреть_лексему()?.вид == ВидЛексемы::Идент {
                    if лекс.подсмотреть_лексему()?.текст == "нат" {
                        let _ = лекс.вытащить_лексему()?;
                        return Хорош(Выражение::НатЧисло(лексема, число));
                    }
                }
                Хорош(Выражение::ЦелЧисло(лексема, число as i64))
            }
            ВидЛексемы::ВещЧисло => {
                match лексема.текст.parse() {
                    Хорош(число) => Хорош(Выражение::ВещЧисло(лексема, число)),
                    Ошиб(_ошибка) => {
                        диагностика!(&лексема.лок, "ОШИБКА", "Некорректное вещественное число");
                        Ошиб(())
                    }
                }
            }
            ВидЛексемы::Идент => {
                let mut цепочка_аргументов = Вектор::new();
                while лекс.подсмотреть_лексему()?.вид == ВидЛексемы::ОткрытаяСкобка {
                    let ключ = лекс.вытащить_лексему().unwrap();
                    цепочка_аргументов.push(Аргументы {
                        ключ,
                        выражения: разобрать_список_аргументов_вызова(лекс)?
                    });
                }
                if цепочка_аргументов.len() == 0 {
                    Хорош(Выражение::Идент(лексема))
                } else {
                    Хорош(Выражение::ЦепочкаВызовов {
                        имя: лексема,
                        цепочка_аргументов,
                    })
                }
            },
            ВидЛексемы::Строка => Хорош(Выражение::Строка(лексема)),
            ВидЛексемы::ОткрытаяСкобка => {
                let выражение = Выражение::разобрать(лекс)?;
                let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ЗакрытаяСкобка])?;
                Хорош(выражение)
            }
            ВидЛексемы::Не => {
                let ключ = лексема;
                let выражение = Box::new(Выражение::разобрать(лекс)?);
                Хорош(Выражение::Отрицание{ключ, выражение})
            }
            ВидЛексемы::Минус => {
                let ключ = лексема;
                let выражение = Box::new(Выражение::разобрать_первичное(лекс)?);
                Хорош(Выражение::УнарныйМинус{ключ, выражение})
            }
            ВидЛексемы::КлючИстина => Хорош(Выражение::Лог(лексема, true)),
            ВидЛексемы::КлючЛожь => Хорош(Выражение::Лог(лексема, false)),
            _ => unreachable!(),
        }
    }

    fn разобрать_биноп(лекс: &mut Лексер, приоритет: usize) -> Результат<Выражение> {
        if приоритет > ВидБинопа::МАКС_ПРИОРИТЕТ {
            return Выражение::разобрать_первичное(лекс);
        }

        let mut левое = Выражение::разобрать_биноп(лекс, приоритет + 1)?;
        while let Некий(вид) = ВидБинопа::по_виду_лексемы(&лекс.подсмотреть_лексему()?.вид) {
            if вид.приоритет() != приоритет {
                break;
            }
            let ключ = лекс.вытащить_лексему().unwrap();
            let правое = Выражение::разобрать_биноп(лекс, приоритет + 1)?;
            левое = Выражение::Биноп {
                вид,
                ключ,
                левое: Box::new(левое),
                правое: Box::new(правое),
            }
        }
        Хорош(левое)
    }

    pub fn разобрать(лекс: &mut Лексер) -> Результат<Выражение> {
        Выражение::разобрать_биноп(лекс, 0)
    }
}

#[derive(Debug)]
pub struct ВеткаВилки {
    pub ключ: Лексема,
    pub выражение: Выражение,
    pub тело: Вектор<Утверждение>,
}

#[derive(Debug)]
pub enum Утверждение {
    Присваивание{ключ: Лексема, левое: Выражение, правое: Выражение},
    Выражение{выражение: Выражение},
    Пока{ключ: Лексема, условие: Выражение, тело: Вектор<Утверждение>},
    Для{ключ: Лексема, индекс: Лексема, нижняя_граница: Выражение, верхняя_граница: Выражение, тело: Вектор<Утверждение>},
    Если{ключ: Лексема, условие: Выражение, тело: Вектор<Утверждение>, иначе: Вектор<Утверждение>},
    Вернуть{ключ: Лексема, выражение: Опция<Выражение>},
    ДекларацияПеременной{ключ: Лексема, имя: Лексема, тип: Выражение, значение: Опция<Выражение>},
    ДекларацияКонстанты{ключ: Лексема, имя: Лексема, значение: Выражение},
    Вилка {ключ: Лексема, выражение: Выражение, ветки: Вектор<ВеткаВилки>, любое: Опция<(Лексема, Вектор<Утверждение>)>},
}

#[derive(Debug)]
pub struct Параметр {
    pub имя: Лексема,
    pub тип: Выражение,
}

#[derive(Debug)]
pub enum ТелоПроцедуры {
    Внутренее { блок: Вектор<Утверждение> },
    Внешнее { символ: Лексема },
}

#[derive(Debug)]
pub struct Процедура {
    pub имя: Лексема,
    pub параметры: Вектор<Параметр>,
    pub тип_результата: Опция<Выражение>,
    pub тело: ТелоПроцедуры,
}

fn разобрать_утверждение(лекс: &mut Лексер) -> Результат<Утверждение> {
    match лекс.подсмотреть_лексему()?.вид {
        ВидЛексемы::КлючЕсли => {
            let ключ = лекс.вытащить_лексему().unwrap();
            let условие = Выражение::разобрать(лекс)?;
            let тело = разобрать_блок_кода(лекс)?;
            let иначе;
            if лекс.подсмотреть_лексему()?.вид == ВидЛексемы::КлючИначе {
                let _ = лекс.вытащить_лексему()?;
                иначе = разобрать_блок_кода(лекс)?;
            } else {
                иначе = вектор![]
            }
            Хорош(Утверждение::Если{ключ, условие, тело, иначе})
        }
        ВидЛексемы::КлючПока => {
            let ключ = лекс.вытащить_лексему().unwrap();
            let условие = Выражение::разобрать(лекс)?;
            let тело = разобрать_блок_кода(лекс)?;
            Хорош(Утверждение::Пока{ключ, условие, тело})
        }
        ВидЛексемы::КлючДля => {
            let ключ = лекс.вытащить_лексему().unwrap();
            let индекс = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
            let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::Присваивание])?;
            let нижняя_граница = Выражение::разобрать(лекс)?;
            let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаТочка])?;
            let верхняя_граница = Выражение::разобрать(лекс)?;
            let тело = разобрать_блок_кода(лекс)?;
            Хорош(Утверждение::Для{ключ, индекс, нижняя_граница, верхняя_граница, тело})
        }
        ВидЛексемы::КлючВернуть => {
            let ключ = лекс.вытащить_лексему().unwrap();
            if лекс.подсмотреть_лексему()?.вид == ВидЛексемы::ТочкаЗапятая {
                let _ = лекс.вытащить_лексему().unwrap();
                Хорош(Утверждение::Вернуть{ключ, выражение: Нету})
            } else {
                let выражение = Некий(Выражение::разобрать(лекс)?);
                let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
                Хорош(Утверждение::Вернуть{ключ, выражение})
            }
        }
        ВидЛексемы::КлючПер => {
            let ключ = лекс.вытащить_лексему().unwrap();
            let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
            let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::Двоеточие])?;
            let тип = Выражение::разобрать(лекс)?;
            let значение = match лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая, ВидЛексемы::Присваивание])?.вид {
                ВидЛексемы::ТочкаЗапятая => Нету,
                ВидЛексемы::Присваивание => {
                    let значение = Выражение::разобрать(лекс)?;
                    let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
                    Некий(значение)
                }
                _ => unreachable!()
            };
            Хорош(Утверждение::ДекларацияПеременной{ключ, имя, тип, значение})
        }
        ВидЛексемы::КлючКонст => {
            let ключ = лекс.вытащить_лексему().unwrap();
            let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
            let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::Присваивание])?;
            let значение = Выражение::разобрать(лекс)?;
            let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
            Хорош(Утверждение::ДекларацияКонстанты{ключ, имя, значение})
        }
        ВидЛексемы::КлючВилка => {
            let ключ = лекс.вытащить_лексему().unwrap();
            let выражение = Выражение::разобрать(лекс)?;
            let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::КлючНч])?;
            let mut ветки = Вектор::new();
            let mut любое = Нету;
            'разбор_веток: loop {
                let ключ_ветки = лекс.вытащить_лексему_вида(&[
                    ВидЛексемы::КлючКогда,
                    ВидЛексемы::КлючКц,
                ])?;
                match ключ_ветки.вид {
                    ВидЛексемы::КлючКогда => {
                        if лекс.подсмотреть_лексему()?.вид == ВидЛексемы::КлючЛюбое {
                            let _ = лекс.вытащить_лексему().unwrap();
                            любое = Некий((ключ_ветки, разобрать_блок_кода(лекс)?));
                            лекс.вытащить_лексему_вида(&[ВидЛексемы::КлючКц])?;
                            break 'разбор_веток;
                        } else {
                            ветки.push(ВеткаВилки {
                                ключ: ключ_ветки,
                                выражение: Выражение::разобрать(лекс)?,
                                тело: разобрать_блок_кода(лекс)?,
                            });
                        }
                    }
                    ВидЛексемы::КлючКц => break 'разбор_веток,
                    _ => unreachable!(),
                }
            }
            Хорош(Утверждение::Вилка{ключ, выражение, ветки, любое})
        }
        _ => {
            let левое = Выражение::разобрать(лекс)?;
            let ключ = лекс.вытащить_лексему_вида(&[
                ВидЛексемы::Присваивание,
                ВидЛексемы::ТочкаЗапятая,
            ])?;
            match ключ.вид {
                ВидЛексемы::Присваивание => {
                    let правое = Выражение::разобрать(лекс)?;
                    let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
                    Хорош(Утверждение::Присваивание {ключ, левое, правое})
                }
                ВидЛексемы::ТочкаЗапятая => Хорош(Утверждение::Выражение {выражение: левое}),
                _ => unreachable!(),
            }
        }
    }
}

fn разобрать_блок_кода(лекс: &mut Лексер) -> Результат<Вектор<Утверждение>> {
    let mut блок = Вектор::new();
    let ключ = лекс.вытащить_лексему_вида(&[ВидЛексемы::КлючНч, ВидЛексемы::КлючТо])?;
    match ключ.вид {
        ВидЛексемы::КлючНч => loop {
            if лекс.подсмотреть_лексему()?.вид == ВидЛексемы::КлючКц {
                let _ = лекс.вытащить_лексему()?;
                break;
            }
            блок.push(разобрать_утверждение(лекс)?);
        }
        ВидЛексемы::КлючТо => блок.push(разобрать_утверждение(лекс)?),
        _ => unreachable!()
    }
    Хорош(блок)
}

fn разобрать_список_аргументов_вызова(лекс: &mut Лексер) -> Результат<Вектор<Выражение>> {
    let mut аргументы = Вектор::new();

    // СДЕЛАТЬ: ввести идиому лекс.вытащить_лексему_если()
    if лекс.подсмотреть_лексему()?.вид == ВидЛексемы::ЗакрытаяСкобка {
        let _ = лекс.вытащить_лексему()?;
    } else {
        'разбор_аргументов: loop {
            аргументы.push(Выражение::разобрать(лекс)?);
            let лексема = лекс.вытащить_лексему_вида(&[
                ВидЛексемы::ЗакрытаяСкобка,
                ВидЛексемы::Запятая
            ])?;
            if лексема.вид == ВидЛексемы::ЗакрытаяСкобка {
                break 'разбор_аргументов
            }
        }
    }
    Хорош(аргументы)
}

fn разобрать_список_параметров_процедуры(лекс: &mut Лексер) -> Результат<Вектор<Параметр>> {
    let mut параметры: Вектор<Параметр> = Вектор::new();
    let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ОткрытаяСкобка])?;
    if лекс.подсмотреть_лексему()?.вид == ВидЛексемы::ЗакрытаяСкобка {
        let _ = лекс.вытащить_лексему()?;
    } else {
        'разбор_параметров: loop {
            let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
            if let Некий(существующий_параметр) = параметры.iter().find(|параметр| параметр.имя.текст == имя.текст) {
                диагностика!(&имя.лок, "ОШИБКА", "переопределение параметра «{имя}»",
                             имя = имя.текст);
                диагностика!(&существующий_параметр.имя.лок, "ИНФО", "параметр с тем же именем определен тут");
                return Ошиб(());
            }
            let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::Двоеточие])?;
            let тип = Выражение::разобрать(лекс)?;
            параметры.push(Параметр {имя, тип});
            let лексема = лекс.вытащить_лексему_вида(&[
                ВидЛексемы::ЗакрытаяСкобка,
                ВидЛексемы::Запятая
            ])?;
            if лексема.вид == ВидЛексемы::ЗакрытаяСкобка {
                break 'разбор_параметров
            }
        }
    }
    Хорош(параметры)
}

impl Процедура {
    pub fn разобрать(лекс: &mut Лексер) -> Результат<Процедура> {
        let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
        let параметры = разобрать_список_параметров_процедуры(лекс)?;
        let тип_результата = if лекс.подсмотреть_лексему()?.вид == ВидЛексемы::Двоеточие {
            let _ = лекс.вытащить_лексему().unwrap();
            let тип = Выражение::разобрать(лекс)?;
            Некий(тип)
        } else {
            Нету
        };
        let тело = if лекс.подсмотреть_лексему()?.вид == ВидЛексемы::КлючВнешняя {
            let _ = лекс.вытащить_лексему().unwrap();
            let символ = лекс.вытащить_лексему_вида(&[ВидЛексемы::Строка])?;
            let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
            ТелоПроцедуры::Внешнее {символ}
        } else {
            let блок = разобрать_блок_кода(лекс)?;
            ТелоПроцедуры::Внутренее {блок}
        };
        Хорош(Процедура{имя, параметры, тело, тип_результата})
    }
}

#[derive(Debug)]
pub struct Константа {
    pub имя: Лексема,
    pub выражение: Выражение,
}

impl Константа {
    pub fn разобрать(лекс: &mut Лексер) -> Результат<Константа> {
        let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
        let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::Присваивание])?;
        let выражение = Выражение::разобрать(лекс)?;
        let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
        Хорош(Константа{имя, выражение})
    }
}
