/// Промежуточное Представление

use стд::прелюдия::*;
use super::Результат;
use std::collections::HashMap;
use std::path::PathBuf;
use синтаксис::*;
use диагностика::*;
use лексика::*;
use типизация::*;
use интерпретатор::{Машина, РАЗМЕР_СЛОВА};
use std::convert::TryInto;

/// Инструкция промежуточного представления
#[derive(Debug, Clone, PartialEq)]
pub enum ВидИнструкции {
    Ноп,
    // СДЕЛАТЬ: инструкция Вещественное32(f32)
    /// Протолкнуть целое значение на стек аргументов.
    Натуральное(usize), // СДЕЛАТЬ: по возможности, использовать u64 вместо usize для значений пп
    Целое(i64),
    Вытолкнуть,
    Продублировать,
    /// Протолкнуть указатель на глобальные данные.
    ///
    /// Эта инструкция нужна потому, что мы не знаем во время
    /// компиляции где начинаются данные. Мы это только знаем во время
    /// интерпретации, либо генерации машинного кода.
    ГлобальныеДанные(i32),

    ВыделитьНаСтеке(u64),
    ОсвободитьСоСтека(u64),
    ВершинаСтека(i32),

    СохранитьКадр,
    ВосстановитьКадр,
    Кадр(i32),

    АргументНаСтек,
    АргументСоСтека,

    Записать8,
    Записать16,
    Записать32,
    Записать64,
    ПрочитатьБезЗнак8,
    ПрочитатьБезЗнак16,
    ПрочитатьБезЗнак32,
    ПрочитатьЗнак8,
    ПрочитатьЗнак16,
    ПрочитатьЗнак32,
    Прочитать64,
    СкопироватьПамять,
    ПамятьРавно,
    НатСложение,
    НатВычитание,
    НатУмножение,
    НатДеление,
    НатОстаток,
    НатМеньше,
    НатМеньшеРавно,
    НатБольше,
    НатБольшеРавно,
    НатРавно,
    ЦелБольше,
    ЦелБольшеРавно,
    ЦелМеньше,
    ЦелМеньшеРавно,
    ЦелУмножение,
    ЦелДеление,
    ЦелОстаток,
    ЦелОтриц,
    КонвертНат64Вещ32,
    КонвертЦел64Вещ32,
    КонвертВещ32Нат64,
    КонвертВещ32Цел64,
    Вещ32Сложение,
    Вещ32Вычитание,
    Вещ32Умножение,
    Вещ32Деление,
    Вещ32Меньше,
    Вещ32МеньшеРавно,
    Вещ32Больше,
    Вещ32БольшеРавно,
    Вещ32Отриц,
    ЛогОтрицание,
    БитИли,
    БитИ,
    БитЛибо,
    БитСмещениеВлево,
    БитСмещениеВправо,
    ПечатьСтроки,
    Ввод,
    Возврат,
    ВнутреннийВызов(usize),
    ВнешнийВызов{индекс: usize, арность: usize, результат: Опция<Тип>},
    // СДЕЛАТЬ: инструкции изменения потока исполнения должны принимать относительное смещение.
    // Данный подход позволяет создавать легко перемещаемый код. Хотя, я не уверен, что это подойдет
    // для ВызватьВнутренююПроцедуру.
    //
    // Возможно имеет смысл пойти по пути BEAM и использовать ярлыки-инструкции. Это позволит легко
    // удалять целые инструкции на этапе оптимизации.
    Прыжок(usize),
    УсловныйПрыжок(usize),
    СисВызов{ арность: usize },
}

#[derive(Clone)]
pub struct Инструкция {
    pub лок: Лок,
    pub вид: ВидИнструкции,
}

#[derive(Debug, Clone)]
pub struct СкомпПеременная {
    pub имя: Лексема,
    pub тип: Тип,
    pub смещение: i32,
}

#[derive(Default, Clone)]
pub struct ОбластьВидимости {
    pub переменные: HashMap<String, СкомпПеременная>,
    pub константы: HashMap<String, СкомпКонстанта>,
    pub размер_переменных_на_стеке: usize,
}

#[derive(Default, Clone)]
pub struct ЛокальныеИмена {
    pub стек_областей: Vec<ОбластьВидимости>,
}

impl ЛокальныеИмена {
    fn найти_переменную_по_имени(&self, имя: &str) -> Опция<&СкомпПеременная> {
        self.стек_областей.iter().rev().find_map(|область| область.переменные.get(имя))
    }

    fn найти_константу_по_имени(&self, имя: &str) -> Опция<&СкомпКонстанта> {
        self.стек_областей.iter().rev().find_map(|область| область.константы.get(имя))
    }
}

#[derive(Debug, Clone)]
pub enum ТочкаВхода {
    Внутреняя { адрес: usize },
    Внешняя { индекс: usize },
}

#[derive(Clone, Debug)]
pub struct РезультатСкомпПроцедуры {
    тип: Тип,
    смещение_от_кадра: i32,
}

#[derive(Debug, Clone)]
pub struct СкомпПроцедура {
    pub имя: Лексема,
    pub параметры: Vec<СкомпПеременная>,
    pub результат: Опция<РезультатСкомпПроцедуры>,
    pub точка_входа: ТочкаВхода,
}

#[derive(Debug, Clone)]
pub struct СкомпКонстанта {
    pub имя: Лексема,
    pub тип: Тип,
    pub значение_или_адрес: u64,
}

/// Промежуточное Представление
#[derive(Default, Clone)]
pub struct ПП {
    pub код: Vec<Инструкция>,
    pub иниц_данные: Vec<u8>,
    pub размер_неиниц_данных: usize,
    pub заплатки_неиниц_указателей: Vec<usize>,
    pub строки: HashMap<String, usize>,
    pub внешние_символы: HashMap<String, usize>,
    pub библиотеки: HashMap<String, usize>,
}

impl ПП {
    pub fn вывалить(&self, точка_входа: usize) {
        println!("Инструкции ({количество} {инструкций}):",
                 количество = self.код.len(),
                 инструкций = ЧИСУЩ_ИНСТРУКЦИЙ.текст(self.код.len()));
        let ширина_столбца_индекса = self.код.len().to_string().len();
        let mut начало = 0;
        while начало < self.код.len() {
            let mut конец = начало;
            while конец < self.код.len() && self.код[начало].лок == self.код[конец].лок{
                конец += 1;
            }
            let Лок{путь_к_файлу, строка, столбец} = &self.код[начало].лок;
            println!("{путь_к_файлу}:{строка}:{столбец}: ", путь_к_файлу = путь_к_файлу.display());
            for индекс in начало..конец {
                print!("    {индекс:0>ширина_столбца_индекса$}: {вид:?}", вид = self.код[индекс].вид);
                if точка_входа == индекс {
                    print!(" <- точка входа");
                }
                println!();
            }
            начало = конец;
        }
        println!();
        // СДЕЛАТЬ: Показать где находятся адреса переменных в памяти
        println!("Инициализированные данные ({размер} {байт}):",
                 размер = self.иниц_данные.len(),
                 байт = ЧИСУЩ_БАЙТ.текст(self.иниц_данные.len()));
        const ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ: usize = 16;
        for строка in 0..self.иниц_данные.len()/ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ {
            let адрес = строка*ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ;
            print!("    {адрес:#08X}: ");
            let байты = &self.иниц_данные[адрес..адрес + ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ];
            for байт in байты {
                print!("{байт:#04X} ");
            }
            println!()
        }
        let остаток = self.иниц_данные.len()%ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ;
        if остаток > 0 {
            let адрес = self.иниц_данные.len()/ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ*ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ;
            print!("    {адрес:#08X}: ");
            let байты = &self.иниц_данные[адрес..адрес + остаток];
            for байт in байты {
                print!("{байт:#04X} ");
            }
            println!()
        }
        println!();
        println!("Размер неинициализированных данных:");
        println!("    {размер} {байт}",
                 размер = self.размер_неиниц_данных,
                 байт = ЧИСУЩ_БАЙТ.текст(self.размер_неиниц_данных))
    }
}

#[derive(Default, Clone)]
pub struct Имена {
    pub константы: HashMap<String, СкомпКонстанта>,
    pub процедуры: HashMap<String, СкомпПроцедура>,
    pub переменные: HashMap<String, СкомпПеременная>,
    pub структуры: HashMap<String, Структура>,
}

impl Имена {
    fn верифицировать_переопределение_имени(&self, имя: &Лексема) -> Результат<()> {
        if let Некий(существующая_переменная) = self.переменные.get(&имя.текст) {
            диагностика!(&имя.лок, "ОШИБКА",
                         "уже существует переменная с именем «{имя}»",
                         имя = имя.текст);
            диагностика!(&существующая_переменная.имя.лок, "ИНФО",
                         "она определена здесь здесь. Выберите другое имя.");
            return Ошиб(())
        }

        if let Некий(существующая_процедура) = self.процедуры.get(&имя.текст) {
            диагностика!(&имя.лок, "ОШИБКА",
                         "уже существует процедура с именем «{имя}»",
                         имя = имя.текст);
            диагностика!(&существующая_процедура.имя.лок, "ИНФО",
                         "она определена здесь здесь. Выберите другое имя.");
            return Ошиб(())
        }

        if let Некий(существующая_константа) = self.константы.get(&имя.текст) {
            диагностика!(&имя.лок, "ОШИБКА",
                         "уже существует константа с именем «{имя}»",
                         имя = имя.текст);
            диагностика!(&существующая_константа.имя.лок, "ИНФО",
                         "она определена здесь здесь. Выберите другое имя.");
            return Ошиб(())
        }

        Хорош(())
    }
}

#[derive(Default)]
pub struct Программа {
    pub пп: ПП,
    pub имена: Имена,
}

fn скомпилировать_утверждение_вызова_функции_по_имени(пп: &mut ПП, имена: &Имена, текущая_процедура: &СкомпПроцедура, локальные_имена: &mut ЛокальныеИмена, имя: &Лексема, аргументы: &[Выражение]) -> Результат<()> {
    match имя.текст.as_str() {
        // СДЕЛАТЬ: не позволять переопределять процедуру «печать» в пользовательском коде.
        "печать" => {
            let mut временный_размер = 0;
            for арг in аргументы {
                let тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &арг, &mut временный_размер)?;
                match тип {
                    Тип::Нат64 => {
                        let процедура = достать_и_проверить_процедуру_печати(имена, "печать_нат", &тип, &арг.лок())?;
                        вызвать_процедуру(арг.лок().clone(), имена, процедура, &mut пп.код, &mut временный_размер)?;
                    }
                    Тип::Цел64 => {
                        let процедура = достать_и_проверить_процедуру_печати(имена, "печать_цел", &тип, &арг.лок())?;
                        вызвать_процедуру(арг.лок().clone(), имена, процедура, &mut пп.код, &mut временный_размер)?;
                    }
                    Тип::Лог => {
                        let процедура = достать_и_проверить_процедуру_печати(имена, "печать_лог", &тип, &арг.лок())?;
                        вызвать_процедуру(арг.лок().clone(), имена, процедура, &mut пп.код, &mut временный_размер)?;
                    }
                    Тип::Срез{тип_элемента} => {
                        if *тип_элемента != Тип::Нат8 {
                            сделать!(арг.лок(), "Печать срезов элементов типа «{тип}» пока не поддерживается",
                                     тип = тип_элемента.текст());
                            return Ошиб(())
                        }
                        пп.код.push(Инструкция{ вид: ВидИнструкции::ПечатьСтроки, лок: имя.лок.clone() });
                    }
                    _ => {
                        сделать!(арг.лок(), "печать переменных типа «{тип}»", тип = тип.текст());
                        return Ошиб(())
                    }
                }
            }
            if временный_размер > 0 {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер as u64), лок: имя.лок.clone() });
            }
            Хорош(())
        },
        _ => {
            if let Некий(вызываемая_процедура) = имена.процедуры.get(&имя.текст) {
                if let Некий(результат) = &вызываемая_процедура.результат {
                    диагностика!(&имя.лок, "ОШИБКА", "Данная процедура возвращает результат типа «{тип}». Результаты процедур нельзя игнорировать.", тип = результат.тип.текст());
                    диагностика!(&вызываемая_процедура.имя.лок, "ИНФО", "Процедура определена тут.");
                    return Ошиб(())
                }

                let количество_аргументов = аргументы.len();
                let количество_параметров = вызываемая_процедура.параметры.len();
                if количество_аргументов != количество_параметров {
                    диагностика!(&имя.лок, "ОШИБКА",
                                 "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                 параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                 аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                    return Ошиб(());
                }

                let mut временный_размер = 0;
                for (параметр, аргумент) in вызываемая_процедура.параметры.iter().zip(аргументы.iter()).rev() {
                    let тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, аргумент, &mut временный_размер)?;
                    проверить_типы(&аргумент.лок(), &параметр.тип, &тип)?;
                }
                вызвать_процедуру(имя.лок.clone(), имена, вызываемая_процедура, &mut пп.код, &mut временный_размер)?;
                if временный_размер > 0 {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер as u64), лок: имя.лок.clone() });
                }
                Хорош(())
            } else {
                диагностика!(&имя.лок, "ОШИБКА", "Неизвестная процедура «{имя}»", имя = имя.текст);
                Ошиб(())
            }
        }
    }
}

fn скомпилировать_выражение_вызова_функции_по_имени(пп: &mut ПП, имена: &Имена, текущая_процедура: &СкомпПроцедура, локальные_имена: &ЛокальныеИмена, имя: &Лексема, аргументы: &[Выражение], временный_размер: &mut usize) -> Результат<Тип> {
    match имя.текст.as_str() {
        // СДЕЛАТЬ: не позволять переопределять процедуру интринсиков в пользовательском коде.
        "ввод" => {
            let [массив] = аргументы else {
                let количество_аргументов = аргументы.len();
                let количество_параметров = 1;
                диагностика!(&имя.лок, "ОШИБКА",
                             "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                             параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                             аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                return Ошиб(());
            };
            if let Выражение::Идент(имя) = массив {
                if let Некий(_параметр) = текущая_процедура.параметры.iter().find(|параметр| параметр.имя.текст == имя.текст) {
                    сделать!(&имя.лок, "Ввод параметров");
                    return Ошиб(())
                }
                if let Некий((переменная, локация)) = найти_переменную_по_имени(&имя.текст, имена, текущая_процедура, локальные_имена) {
                    if let Тип::Массив{размер, тип_элемента} = &переменная.тип {
                        if **тип_элемента != Тип::Нат8 {
                            диагностика!(&имя.лок, "ОШИБКА", "Ввод возможет только в массива элементов «{тип_элемента}»", тип_элемента = тип_элемента.текст());
                            return Ошиб(())
                        }

                        // СДЕЛАТЬ: принимать срез по аналогии с ПечатьСтроки
                        локация.протолкнуть_смещение(пп, &имя.лок, переменная.смещение);
                        пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(*размер), лок: имя.лок.clone() });
                        пп.код.push(Инструкция{ вид: ВидИнструкции::Ввод, лок: имя.лок.clone() });
                        return Хорош(Тип::Нат64);
                    } else {
                        // СДЕЛАТЬ: было бы полезно читать ввод в срезы.
                        диагностика!(&имя.лок, "ОШИБКА",
                                     "Переменная «{имя}» не является массивом. Ввод можно осуществлять только в массивы на данный момент.",
                                     имя = &имя.текст);
                        return Ошиб(())
                    }
                }

                диагностика!(&имя.лок, "ОШИБКА",
                             "не существует ни параметров, ни переменных с имением «{имя}»",
                             имя = &имя.текст);
                Ошиб(())
            } else {
                // СДЕЛАТЬ: возможно данные аргумент должен быть передан по ссылке.
                // Но мы пока не имеем подобного механизма.
                диагностика!(&имя.лок, "ОШИБКА", "Ввод требует имя массива в качестве первого аргумента");
                Ошиб(())
            }
        }
        "срез" => {
            let [массив, начало_среза, размер_среза] = аргументы else {
                let количество_аргументов = аргументы.len();
                let количество_параметров = 3;
                диагностика!(&имя.лок, "ОШИБКА",
                             "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                             параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                             аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                return Ошиб(());
            };

            if let Выражение::Идент(имя) = массив {
                if let Некий((переменная, локация)) = найти_переменную_по_имени(&имя.текст, имена, текущая_процедура, локальные_имена) {
                    match &переменная.тип {
                        Тип::Массив{размер: _, тип_элемента} => {
                            let тип_среза = Тип::Срез {
                                тип_элемента: тип_элемента.clone()
                            };

                            let тип_размера_среза = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &размер_среза, временный_размер)?;
                            проверить_типы(&размер_среза.лок(), &Тип::Нат64, &тип_размера_среза)?;
                            локация.протолкнуть_смещение(пп, &имя.лок, переменная.смещение);

                            let тип_начала = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &начало_среза, временный_размер)?;
                            проверить_типы(&размер_среза.лок(), &Тип::Нат64, &тип_начала)?;

                            пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(тип_элемента.размер(&имена.структуры)), лок: имя.лок.clone() });
                            пп.код.push(Инструкция{ вид: ВидИнструкции::НатУмножение, лок: имя.лок.clone() });
                            пп.код.push(Инструкция{ вид: ВидИнструкции::НатСложение, лок: имя.лок.clone() });

                            пп.код.push(Инструкция{ вид: ВидИнструкции::ВыделитьНаСтеке(тип_среза.размер(&имена.структуры) as u64), лок: имя.лок.clone() });
                            *временный_размер += тип_среза.размер(&имена.структуры);
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаСтека(СРЕЗ_АДРЕС_СМЕЩЕНИЕ as i32), лок: имя.лок.clone() });
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Записать64, лок: имя.лок.clone() });
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаСтека(СРЕЗ_РАЗМЕР_СМЕЩЕНИЕ as i32), лок: имя.лок.clone() });
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Записать64, лок: имя.лок.clone() });

                            пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаСтека(0), лок: имя.лок.clone() });

                            return Хорош(тип_среза);
                        }
                        Тип::Срез{тип_элемента} => {
                            let тип_среза = Тип::Срез {
                                тип_элемента: тип_элемента.clone()
                            };

                            let тип_размера_среза = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &размер_среза, временный_размер)?;
                            проверить_типы(&размер_среза.лок(), &Тип::Нат64, &тип_размера_среза)?;

                            локация.протолкнуть_смещение(пп, &имя.лок, переменная.смещение);
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(СРЕЗ_АДРЕС_СМЕЩЕНИЕ), лок: имя.лок.clone()});
                            пп.код.push(Инструкция{ вид: ВидИнструкции::НатСложение, лок: имя.лок.clone()});
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Прочитать64, лок: имя.лок.clone()});

                            let тип_начала = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &начало_среза, временный_размер)?;
                            проверить_типы(&размер_среза.лок(), &Тип::Нат64, &тип_начала)?;

                            пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(тип_элемента.размер(&имена.структуры)), лок: имя.лок.clone() });
                            пп.код.push(Инструкция{ вид: ВидИнструкции::НатУмножение, лок: имя.лок.clone() });
                            пп.код.push(Инструкция{ вид: ВидИнструкции::НатСложение, лок: имя.лок.clone() });

                            пп.код.push(Инструкция{ вид: ВидИнструкции::ВыделитьНаСтеке(тип_среза.размер(&имена.структуры) as u64), лок: имя.лок.clone() });
                            *временный_размер += тип_среза.размер(&имена.структуры);
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаСтека(СРЕЗ_АДРЕС_СМЕЩЕНИЕ as i32), лок: имя.лок.clone() });
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Записать64, лок: имя.лок.clone() });
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаСтека(СРЕЗ_РАЗМЕР_СМЕЩЕНИЕ as i32), лок: имя.лок.clone() });
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Записать64, лок: имя.лок.clone() });

                            пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаСтека(0), лок: имя.лок.clone() });

                            return Хорош(тип_среза);
                        }
                        _ => {
                            диагностика!(&имя.лок, "ОШИБКА",
                                         "Переменная «{имя}» не является массивом. Срезы возможны только для массивов либо других срезов.",
                                         имя = &имя.текст);
                            return Ошиб(());
                        }
                    }
                }

                диагностика!(&имя.лок, "ОШИБКА",
                             "не существует переменных с имением «{имя}»",
                             имя = &имя.текст);
                Ошиб(())
            } else {
                // СДЕЛАТЬ: возможно данные аргумент должен быть передан по ссылке.
                // Но мы пока не имеем подобного механизма.
                диагностика!(&имя.лок, "ОШИБКА", "Срез требует имя массива в качестве первого аргумента");
                Ошиб(())
            }
        }
        "сисвызов" => {
            if аргументы.len() == 0 {
                сделать!(&имя.лок, "Диагностика некорректной арности «сисвызов»-ов");
                return Ошиб(());
            }
            let арность = аргументы.len() - 1;

            for аргумент in аргументы {
                let тип_аргумента = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, аргумент, временный_размер)?;
                проверить_типы(&аргумент.лок(), &Тип::Нат64, &тип_аргумента)?;
            }

            пп.код.push(Инструкция{ вид: ВидИнструкции::СисВызов{арность}, лок: имя.лок.clone() });
            Хорош(Тип::Нат64)
        }
        "размер" => {
            let [выражение] = аргументы else {
                let количество_аргументов = аргументы.len();
                let количество_параметров = 1;
                диагностика!(&имя.лок, "ОШИБКА",
                             "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                             параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                             аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                return Ошиб(());
            };

            let тип_выражения = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &выражение, временный_размер)?;
            match тип_выражения {
                Тип::Срез{..} => {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(СРЕЗ_РАЗМЕР_СМЕЩЕНИЕ), лок: имя.лок.clone()});
                    пп.код.push(Инструкция{ вид: ВидИнструкции::НатСложение, лок: имя.лок.clone()});
                    пп.код.push(Инструкция{ вид: ВидИнструкции::Прочитать64, лок: имя.лок.clone()});
                    Хорош(Тип::Цел64)
                }
                _ => {
                    диагностика!(&выражение.лок(), "ОШИБКА", "Несоответствие типов данных. Ожидался тип «строка», либо «срез», но повстречался тип «{действительный}»",
                                 действительный = тип_выражения.текст());
                    Ошиб(())
                }
            }
        }
        "адрес" => {
            let [выражение] = аргументы else {
                let количество_аргументов = аргументы.len();
                let количество_параметров = 1;
                диагностика!(&имя.лок, "ОШИБКА",
                             "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                             параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                             аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                return Ошиб(());
            };

            let тип_выражения = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &выражение, временный_размер)?;
            match тип_выражения {
                Тип::Срез{..} => {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(СРЕЗ_АДРЕС_СМЕЩЕНИЕ), лок: имя.лок.clone()});
                    пп.код.push(Инструкция{ вид: ВидИнструкции::НатСложение, лок: имя.лок.clone()});
                    пп.код.push(Инструкция{ вид: ВидИнструкции::Прочитать64, лок: имя.лок.clone()});
                    Хорош(Тип::Нат64)
                }
                _ => {
                    диагностика!(&выражение.лок(), "ОШИБКА", "Несоответствие типов данных. Ожидался тип «строка», либо «срез», но повстречался тип «{действительный}»",
                                 действительный = тип_выражения.текст());
                    Ошиб(())
                }
            }
        }
        _ => {
            if let Некий(процедура) = имена.процедуры.get(&имя.текст) {
                // СДЕЛАТЬ: дупликация кода между компиляцией вызова процедур как выражений и как утверждений.

                let количество_аргументов = аргументы.len();
                let количество_параметров = процедура.параметры.len();
                if количество_аргументов != количество_параметров {
                    диагностика!(&имя.лок, "ОШИБКА",
                                 "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                 параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                 аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                    return Ошиб(());
                }

                for (параметр, аргумент) in процедура.параметры.iter().zip(аргументы.iter()).rev() {
                    let тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, аргумент, временный_размер)?;
                    проверить_типы(&аргумент.лок(), &параметр.тип, &тип)?;
                }
                вызвать_процедуру(имя.лок.clone(), имена, &процедура, &mut пп.код, временный_размер)?;

                if let Некий(результат) = &процедура.результат {
                    return Хорош(результат.тип.clone())
                } else {
                    диагностика!(&имя.лок, "ОШИБКА", "Данная процедура ничего не возвращает. Её нельзя использовать как выражение. Только как утверждение.");
                    return Ошиб(())
                }
            }

            if let Некий((переменная, локация)) = найти_переменную_по_имени(&имя.текст, имена, текущая_процедура, локальные_имена) {
                match &переменная.тип {
                    Тип::Массив{тип_элемента, ..} => {
                        let [индекс] = &аргументы[..] else {
                            диагностика!(&имя.лок, "ОШИБКА", "Некорректная размерность массива. Ожидался 1 индекс, но повстречалось {ранк}", ранк = аргументы.len());
                            return Ошиб(());
                        };

                        локация.протолкнуть_смещение(пп, &имя.лок, переменная.смещение);
                        индексировать_массив(тип_элемента, пп, имена, текущая_процедура, локальные_имена, индекс, временный_размер)?;
                        if тип_элемента.примитивный() {
                            прочитать_примитивный_тип(&имя.лок, &mut пп.код, &имена.структуры, &тип_элемента)?;
                        }
                        return Хорош(*тип_элемента.clone())
                    }
                    Тип::Срез{тип_элемента} => {
                        let [индекс] = &аргументы[..] else {
                            диагностика!(&имя.лок, "ОШИБКА", "Некорректная размерность среза. Ожидался 1 индекс, но повстречалось {ранк}", ранк = аргументы.len());
                            return Ошиб(());
                        };
                        локация.протолкнуть_смещение(пп, &имя.лок, переменная.смещение + СРЕЗ_АДРЕС_СМЕЩЕНИЕ as i32);
                        прочитать_примитивный_тип(&имя.лок, &mut пп.код, &имена.структуры, &Тип::Нат64)?;
                        индексировать_массив(тип_элемента, пп, имена, текущая_процедура, локальные_имена, индекс, временный_размер)?;
                        if тип_элемента.примитивный() {
                            прочитать_примитивный_тип(&имя.лок, &mut пп.код, &имена.структуры, &тип_элемента)?;
                        }
                        return Хорош(*тип_элемента.clone())
                    }
                    _ => {
                        диагностика!(&имя.лок, "ОШИБКА", "Невозможно индексировать тип «{тип}»", тип = переменная.тип.текст());
                        return Ошиб(())
                    }
                }
            }

            println!("{текущая_процедура:?}");
            диагностика!(&имя.лок, "ОШИБКА", "Неизвестное имя «{имя}»", имя = имя.текст);
            Ошиб(())
        }
    }
}

fn скомпилировать_выражение(пп: &mut ПП, имена: &Имена, текущая_процедура: &СкомпПроцедура, локальные_имена: &ЛокальныеИмена, выражение: &Выражение, временный_размер: &mut usize) -> Результат<Тип> {
    match выражение {
        Выражение::Лог(лексема, значение) => {
            if *значение {
                пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(1), лок: лексема.лок.clone() });
            } else {
                пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(0), лок: лексема.лок.clone() });
            }
            Хорош(Тип::Лог)
        }
        Выражение::ЦелЧисло(лексема, число) => {
            пп.код.push(Инструкция{ вид: ВидИнструкции::Целое(*число), лок: лексема.лок.clone() });
            Хорош(Тип::Цел64)
        },
        Выражение::НатЧисло(лексема, число) => {
            пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(*число as usize), лок: лексема.лок.clone() });
            Хорош(Тип::Нат64)
        },
        Выражение::ВещЧисло(лексема, число) => {
            let число = u32::from_le_bytes(число.to_le_bytes()) as usize;
            пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(число), лок: лексема.лок.clone() });
            Хорош(Тип::Вещ32)
        },
        Выражение::Строка(строка) => {
            let (указатель, длинна) = if let Некий(указатель) = пп.строки.get(&строка.текст) {
                (*указатель, строка.текст.len())
            } else {
                let указатель = пп.иниц_данные.len();
                let длинна = строка.текст.len();
                пп.иниц_данные.extend(строка.текст.as_bytes());
                пп.иниц_данные.push(0); // ЗАМЕТКА: нулл-терминатор на случае если мы захотим что-то передать в сишный код
                пп.строки.insert(строка.текст.clone(), указатель);
                (указатель, длинна)
            };
            let тип = Тип::Срез { тип_элемента: Box::new(Тип::Нат8) };
            пп.код.push(Инструкция{ вид: ВидИнструкции::ВыделитьНаСтеке(тип.размер(&имена.структуры) as u64), лок: строка.лок.clone() });
            *временный_размер += тип.размер(&имена.структуры);

            // СДЕЛАТЬ: несколько много инструкций для компиляции простого строкового литерала
            // Может быть имеет смысл ввести сокращения для инструкций? Что-то типа Записать64НаСтеке(i32).

            пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(длинна), лок: строка.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаСтека(СРЕЗ_РАЗМЕР_СМЕЩЕНИЕ as i32), лок: строка.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::Записать64, лок: строка.лок.clone() });

            пп.код.push(Инструкция{ вид: ВидИнструкции::ГлобальныеДанные(указатель as i32), лок: строка.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаСтека(СРЕЗ_АДРЕС_СМЕЩЕНИЕ as i32), лок: строка.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::Записать64, лок: строка.лок.clone() });

            пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаСтека(0), лок: строка.лок.clone() });

            Хорош(тип)
        }
        Выражение::Идент(лексема) => {
            if let Некий(константа) = найти_константу_по_имени(&лексема.текст, имена, Некий(локальные_имена)) {
                пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(константа.значение_или_адрес as usize), лок: лексема.лок.clone() });
                return Хорош(константа.тип.clone());
            }
            if let Некий((переменная, локация)) = найти_переменную_по_имени(&лексема.текст, имена, текущая_процедура, локальные_имена) {
                локация.протолкнуть_смещение(пп, &лексема.лок, переменная.смещение);
                if переменная.тип.примитивный() {
                    прочитать_примитивный_тип(&лексема.лок, &mut пп.код, &имена.структуры, &переменная.тип)?;
                }
                return Хорош(переменная.тип.clone());
            }

            диагностика!(&лексема.лок, "ОШИБКА",
                         "не существует ни констант, ни переменных с имением «{имя}»",
                         имя = &лексема.текст);
            Ошиб(())
        }
        Выражение::Биноп {ключ, вид, левое, правое} => {
            match вид {
                ВидБинопа::Поле => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    match &**правое {
                        Выражение::Идент(имя_поля) => {
                            match &левый_тип {
                                Тип::Структура(имя_структуры) => {
                                    let структура = имена
                                        .структуры
                                        .get(имя_структуры)
                                        .expect("Существование структуры должно быть уже проверено на этапе компиляции типа");
                                    if let Некий(поле) = структура.поля.get(&имя_поля.текст) {
                                        пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(поле.смещение), лок: ключ.лок.clone() });
                                        пп.код.push(Инструкция{ вид: ВидИнструкции::НатСложение, лок: ключ.лок.clone() });
                                        if поле.тип.примитивный() {
                                            прочитать_примитивный_тип(&ключ.лок, &mut пп.код, &имена.структуры, &поле.тип)?;
                                        }
                                        Хорош(поле.тип.clone())
                                    } else {
                                        диагностика!(&ключ.лок, "ОШИБКА", "У структуры «{тип}» отстутствует поле «{поле}»", тип = левый_тип.текст(), поле = имя_поля.текст);
                                        Ошиб(())
                                    }
                                }
                                _ => {
                                    диагностика!(&ключ.лок, "ОШИБКА", "У типа «{тип}» отстутствует поле «{поле}»", тип = левый_тип.текст(), поле = имя_поля.текст);
                                    Ошиб(())
                                }
                            }
                        }
                        Выражение::ЦепочкаВызовов{имя: имя_поля, цепочка_аргументов} => {
                            let mut тип_вызываемого = match &левый_тип {
                                Тип::Структура(имя_структуры) => {
                                    let структура = имена
                                        .структуры
                                        .get(имя_структуры)
                                        .expect("Существование структуры должно быть уже проверено на этапе компиляции типа");
                                    if let Некий(поле) = структура.поля.get(&имя_поля.текст) {
                                        пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(поле.смещение), лок: ключ.лок.clone() });
                                        пп.код.push(Инструкция{ вид: ВидИнструкции::НатСложение, лок: ключ.лок.clone() });
                                        if поле.тип.примитивный() {
                                            прочитать_примитивный_тип(&ключ.лок, &mut пп.код, &имена.структуры, &поле.тип)?;
                                        }
                                        поле.тип.clone()
                                    } else {
                                        диагностика!(&ключ.лок, "ОШИБКА", "У структуры «{тип}» отстутствует поле «{поле}»", тип = левый_тип.текст(), поле = имя_поля.текст);
                                        return Ошиб(())
                                    }
                                }
                                _ => {
                                    диагностика!(&ключ.лок, "ОШИБКА", "У типа «{тип}» отстутствует поле «{поле}»", тип = левый_тип.текст(), поле = имя_поля.текст);
                                    return Ошиб(())
                                }
                            };

                            for аргументы in цепочка_аргументов {
                                match &тип_вызываемого {
                                    Тип::Массив{тип_элемента, ..} => {
                                        let [индекс] = &аргументы.выражения[..] else {
                                            диагностика!(&аргументы.ключ.лок, "ОШИБКА", "Некорректная размерность массива. Ожидался 1 индекс, но повстречалось {ранк}", ранк = аргументы.выражения.len());
                                            return Ошиб(());
                                        };

                                        индексировать_массив(тип_элемента, пп, имена, текущая_процедура, локальные_имена, индекс, временный_размер)?;
                                        if тип_элемента.примитивный() {
                                            прочитать_примитивный_тип(&аргументы.ключ.лок, &mut пп.код, &имена.структуры, &тип_элемента)?;
                                        }
                                        тип_вызываемого = *тип_элемента.clone();
                                    }
                                    Тип::Срез{тип_элемента} => {

                                        let [индекс] = &аргументы.выражения[..] else {
                                            диагностика!(&аргументы.ключ.лок, "ОШИБКА", "Некорректная размерность массива. Ожидался 1 индекс, но повстречалось {ранк}", ранк = аргументы.выражения.len());
                                            return Ошиб(());
                                        };

                                        пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(СРЕЗ_АДРЕС_СМЕЩЕНИЕ), лок: аргументы.ключ.лок.clone()});
                                        пп.код.push(Инструкция{ вид: ВидИнструкции::НатСложение, лок: аргументы.ключ.лок.clone()});
                                        пп.код.push(Инструкция{ вид: ВидИнструкции::Прочитать64, лок: аргументы.ключ.лок.clone()});

                                        индексировать_массив(тип_элемента, пп, имена, текущая_процедура, локальные_имена, индекс, временный_размер)?;
                                        if тип_элемента.примитивный() {
                                            прочитать_примитивный_тип(&аргументы.ключ.лок, &mut пп.код, &имена.структуры, &тип_элемента)?;
                                        }
                                        тип_вызываемого = *тип_элемента.clone();
                                    }
                                    _ => {
                                        диагностика!(&аргументы.ключ.лок, "ОШИБКА", "Невозможно индексировать тип «{тип}»", тип = тип_вызываемого.текст());
                                        return Ошиб(())
                                    }
                                }
                            }

                            Хорош(тип_вызываемого)
                        }
                        _ => {
                            диагностика!(&правое.лок(), "ОШИБКА", "Данное выражение не может быть использовано как поле");
                            Ошиб(())
                        }
                    }
                }
                ВидБинопа::НеРавно => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    if левый_тип.примитивный() {
                        пп.код.push(Инструкция{ вид: ВидИнструкции::НатРавно, лок: ключ.лок.clone() });
                    } else {
                        пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(левый_тип.размер(&имена.структуры)), лок: ключ.лок.clone() });
                        пп.код.push(Инструкция{ вид: ВидИнструкции::ПамятьРавно, лок: ключ.лок.clone() });
                    }
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ЛогОтрицание, лок: ключ.лок.clone() });
                    Хорош(Тип::Лог)
                }
                ВидБинопа::Равно => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    if левый_тип.примитивный() {
                        пп.код.push(Инструкция{ вид: ВидИнструкции::НатРавно, лок: ключ.лок.clone() });
                    } else {
                        пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(левый_тип.размер(&имена.структуры)), лок: ключ.лок.clone() });
                        пп.код.push(Инструкция{ вид: ВидИнструкции::ПамятьРавно, лок: ключ.лок.clone() });
                    }
                    Хорош(Тип::Лог)
                }
                ВидБинопа::МеньшеРавно => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Нат64 | Тип::Нат8 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::НатМеньшеРавно, лок: ключ.лок.clone() });
                        }
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелМеньшеРавно, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32МеньшеРавно, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Меньше либо равно для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Ошиб(());
                        }
                    }
                    Хорош(Тип::Лог)
                }
                ВидБинопа::БольшеРавно => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Нат64 | Тип::Нат8 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::НатБольшеРавно, лок: ключ.лок.clone() });
                        }
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелБольшеРавно, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32БольшеРавно, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Больше либо равно для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Ошиб(());
                        }
                    }
                    Хорош(Тип::Лог)
                }
                ВидБинопа::Меньше => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Нат64 | Тип::Нат8 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::НатМеньше, лок: ключ.лок.clone() });
                        }
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелМеньше, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Меньше, лок: ключ.лок.clone() });
                        }
                        _ => {
                            // СДЕЛАТЬ: Поддержка бинопа «меньше» для всех нужных типов
                            диагностика!(&ключ.лок, "ОШИБКА", "Меньше для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Ошиб(());
                        }
                    }
                    Хорош(Тип::Лог)
                }
                ВидБинопа::Больше => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 | Тип::Нат8 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелБольше, лок: ключ.лок.clone() });
                        }
                        Тип::Нат64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::НатБольше, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Больше, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Больше для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Ошиб(());
                        }
                    }
                    Хорош(Тип::Лог)
                }
                ВидБинопа::Или => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Лог | Тип::Нат64 | Тип::Нат8 | Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::БитИли, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&левое.лок(), "ОШИБКА", "Операция «или» не поддерживается для типов «{тип}»", тип = левый_тип.текст());
                            return Ошиб(())
                        }
                    }
                    Хорош(левый_тип.clone())
                }
                ВидБинопа::И => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Лог |Тип::Нат64 | Тип::Нат8 | Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::БитИ, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&левое.лок(), "ОШИБКА", "Операция «и» не поддерживается для типов «{тип}»", тип = левый_тип.текст());
                            return Ошиб(())
                        }
                    }
                    Хорош(левый_тип.clone())
                }
                ВидБинопа::Либо => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Лог | Тип::Нат64 | Тип::Нат8 | Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::БитЛибо, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&левое.лок(), "ОШИБКА", "Операция «либо» не поддерживается для типов «{тип}»", тип = левый_тип.текст());
                            return Ошиб(())
                        }
                    }
                    Хорош(левый_тип.clone())
                }
                ВидБинопа::Сложение => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Нат8 | Тип::Нат64 | Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::НатСложение, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Сложение, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Сложение для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Ошиб(());
                        }
                    }
                    Хорош(левый_тип)
                }
                ВидБинопа::Вычитание => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Нат8 | Тип::Нат64 | Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::НатВычитание, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Вычитание, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Вычитание для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Ошиб(());
                        }
                    }
                    Хорош(левый_тип)
                }
                ВидБинопа::Умножение => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелУмножение, лок: ключ.лок.clone() });
                        }
                        Тип::Нат8 | Тип::Нат64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::НатУмножение, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Умножение, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Перемножение для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Ошиб(());
                        }
                    }
                    Хорош(левый_тип)
                }
                ВидБинопа::Деление => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелДеление, лок: ключ.лок.clone() });
                        }
                        Тип::Нат8 | Тип::Нат64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::НатДеление, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Деление, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Деление для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Ошиб(());
                        }
                    }
                    Хорош(левый_тип)
                }
                ВидБинопа::Остаток => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелОстаток, лок: ключ.лок.clone() }),
                        Тип::Нат8 | Тип::Нат64 => пп.код.push(Инструкция{ вид: ВидИнструкции::НатОстаток, лок: ключ.лок.clone() }),
                        Тип::Вещ32 => {
                            сделать!(&ключ.лок, "Остаток от деления вещественных чисел. Что-то типа fmodf, только встроенный.");
                            return Ошиб(());
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Остаток для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Ошиб(());
                        }
                    }
                    Хорош(левый_тип)
                }
                ВидБинопа::Как => {
                    let значение = левое;
                    let тип = правое;
                    let тип_цели = скомпилировать_тип(пп, тип, имена, Некий(локальные_имена))?;
                    let тип_значения = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &значение, временный_размер)?;

                    if тип_значения == тип_цели {
                        return Хорош(тип_цели);
                    }

                    match &тип_значения {
                        Тип::Нат8 => match &тип_цели {
                            Тип::Нат8 | Тип::Нат64 | Тип::Цел64 => {},
                            Тип::Лог => {
                                пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(0), лок: ключ.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::НатРавно, лок: ключ.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ЛогОтрицание, лок: ключ.лок.clone() });
                            }
                            Тип::Вещ32 => {
                                пп.код.push(Инструкция{ вид: ВидИнструкции::КонвертНат64Вещ32, лок: ключ.лок.clone() });
                            }
                            _ => {
                                диагностика!(&ключ.лок, "ОШИБКА", "Конвертация типа «{тип_значения}» в тип «{тип_цели}» невозможна", тип_значения = тип_значения.текст(), тип_цели = тип_цели.текст());
                                return Ошиб(());
                            }
                        }
                        Тип::Нат64 => match &тип_цели {
                            Тип::Нат64 | Тип::Цел64 => {},
                            Тип::Нат8 => {
                                пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(0xFF), лок: ключ.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::БитИ, лок: ключ.лок.clone() });
                            }
                            Тип::Лог => {
                                пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(0), лок: ключ.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::НатРавно, лок: ключ.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ЛогОтрицание, лок: ключ.лок.clone() });
                            }
                            Тип::Вещ32 => {
                                пп.код.push(Инструкция{ вид: ВидИнструкции::КонвертНат64Вещ32, лок: ключ.лок.clone() });
                            }
                            _ => {
                                диагностика!(&ключ.лок, "ОШИБКА", "Конвертация типа «{тип_значения}» в тип «{тип_цели}» невозможна", тип_значения = тип_значения.текст(), тип_цели = тип_цели.текст());
                                return Ошиб(());
                            }
                        }
                        Тип::Цел64 => match &тип_цели {
                            Тип::Нат64 | Тип::Цел64 => {},
                            Тип::Нат8 => {
                                пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(0xFF), лок: ключ.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::БитИ, лок: ключ.лок.clone() });
                            }
                            Тип::Лог => {
                                пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(0), лок: ключ.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::НатРавно, лок: ключ.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ЛогОтрицание, лок: ключ.лок.clone() });
                            }
                            Тип::Вещ32 => {
                                пп.код.push(Инструкция{ вид: ВидИнструкции::КонвертЦел64Вещ32, лок: ключ.лок.clone() });
                            }
                            _ => {
                                диагностика!(&ключ.лок, "ОШИБКА", "Конвертация типа «{тип_значения}» в тип «{тип_цели}» невозможна", тип_значения = тип_значения.текст(), тип_цели = тип_цели.текст());
                                return Ошиб(());
                            }
                        }
                        Тип::Вещ32 => match &тип_цели {
                            Тип::Нат64 => {
                                пп.код.push(Инструкция{ вид: ВидИнструкции::КонвертВещ32Нат64, лок: ключ.лок.clone() });
                            }
                            Тип::Цел64 => {
                                пп.код.push(Инструкция{ вид: ВидИнструкции::КонвертВещ32Цел64, лок: ключ.лок.clone() });
                            }
                            Тип::Нат8 => {
                                пп.код.push(Инструкция{ вид: ВидИнструкции::КонвертВещ32Нат64, лок: ключ.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(0xFF), лок: ключ.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::БитИ, лок: ключ.лок.clone() });
                            }
                            Тип::Лог => {
                                пп.код.push(Инструкция{ вид: ВидИнструкции::КонвертВещ32Нат64, лок: ключ.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(0), лок: ключ.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::НатРавно, лок: ключ.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ЛогОтрицание, лок: ключ.лок.clone() });
                            }
                            Тип::Вещ32 => {}
                            _ => {
                                диагностика!(&ключ.лок, "ОШИБКА", "Конвертация типа «{тип_значения}» в тип «{тип_цели}» невозможна", тип_значения = тип_значения.текст(), тип_цели = тип_цели.текст());
                                return Ошиб(());
                            }
                        }
                        Тип::Лог => match &тип_цели {
                            Тип::Нат8 | Тип::Нат64 | Тип::Цел64 | Тип::Лог => {},
                            Тип::Вещ32 => {
                                пп.код.push(Инструкция{ вид: ВидИнструкции::КонвертНат64Вещ32, лок: ключ.лок.clone() });
                            }
                            _ => {
                                диагностика!(&ключ.лок, "ОШИБКА", "Конвертация типа «{тип_значения}» в тип «{тип_цели}» невозможна", тип_значения = тип_значения.текст(), тип_цели = тип_цели.текст());
                                return Ошиб(());
                            }
                        }
                        Тип::Срез{..} => match &тип_цели {
                            Тип::Срез{..} => {}
                            _ => {
                                диагностика!(&ключ.лок, "ОШИБКА", "Срезы можно конвертировать только в другие срезы.");
                                return Ошиб(());
                            }
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Конвертация типа «{тип_значения}» в тип «{тип_цели}» невозможна", тип_значения = тип_значения.текст(), тип_цели = тип_цели.текст());
                            return Ошиб(());
                        }
                    }
                    Хорош(тип_цели)
                }
                ВидБинопа::ЛевоеБитовоеСмещение => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &Тип::Нат64, &правый_тип)?;
                    match левый_тип {
                        Тип::Нат64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::БитСмещениеВлево, лок: ключ.лок.clone() });
                        }
                        Тип::Нат8 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::БитСмещениеВлево, лок: ключ.лок.clone() });
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(0xFF), лок: ключ.лок.clone() });
                            пп.код.push(Инструкция{ вид: ВидИнструкции::БитИ, лок: ключ.лок.clone() });
                        }
                        Тип::Цел64 => {
                            сделать!(левое.лок(), "Знаковое битовое смещение пока не поддерживается");
                            return Ошиб(())
                        }
                        _ => {
                            диагностика!(левое.лок(), "ОШИБКА", "Левое битовое смещение для типа «{тип}» не поддерживается", тип = левый_тип.текст());
                            return Ошиб(())
                        }
                    }
                    Хорош(левый_тип.clone())
                }
                ВидБинопа::ПравоеБитовоеСмещение => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &Тип::Нат64, &правый_тип)?;
                    match левый_тип {
                        Тип::Нат64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::БитСмещениеВправо, лок: ключ.лок.clone() });
                        }
                        Тип::Нат8 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::БитСмещениеВправо, лок: ключ.лок.clone() });
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(0xFF), лок: ключ.лок.clone() });
                            пп.код.push(Инструкция{ вид: ВидИнструкции::БитИ, лок: ключ.лок.clone() });
                        }
                        Тип::Цел64 => {
                            сделать!(левое.лок(), "Знаковое битовое смещение пока не поддерживается");
                            return Ошиб(())
                        }
                        _ => {
                            диагностика!(левое.лок(), "ОШИБКА", "Правое битовое смещение для типа «{тип}» не поддерживается", тип = левый_тип.текст());
                            return Ошиб(())
                        }
                    }
                    Хорош(левый_тип.clone())
                }
            }
        }

        Выражение::УнарныйМинус {ключ, выражение} => {
            let тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &выражение, временный_размер)?;
            match тип {
                Тип::Вещ32 => {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Отриц, лок: ключ.лок.clone() });
                    Хорош(тип)
                }
                Тип::Цел64 => {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелОтриц, лок: ключ.лок.clone() });
                    Хорош(тип)
                }
                _ => {
                    диагностика!(&ключ.лок, "ОШИБКА", "Тип «{тип}» не может быть отрицательным", тип = тип.текст());
                    Ошиб(())
                }
            }
        }

        Выражение::ЦепочкаВызовов {имя, цепочка_аргументов} => {
            let mut аргументы = цепочка_аргументов.iter();
            let mut тип_вызываемого = скомпилировать_выражение_вызова_функции_по_имени(пп, имена, текущая_процедура, локальные_имена, имя, &аргументы.next().expect("Цепочка аргументов вызова не может быть пустой").выражения, временный_размер)?;

            for аргументы in аргументы {
                match &тип_вызываемого {
                    Тип::Массив{тип_элемента, ..} => {
                        let [индекс] = &аргументы.выражения[..] else {
                            диагностика!(&аргументы.ключ.лок, "ОШИБКА", "Некорректная размерность массива. Ожидался 1 индекс, но повстречалось {ранк}", ранк = аргументы.выражения.len());
                            return Ошиб(());
                        };

                        индексировать_массив(тип_элемента, пп, имена, текущая_процедура, локальные_имена, индекс, временный_размер)?;
                        if тип_элемента.примитивный() {
                            прочитать_примитивный_тип(&аргументы.ключ.лок, &mut пп.код, &имена.структуры, &тип_элемента)?;
                        }
                        тип_вызываемого = *тип_элемента.clone();
                    }
                    Тип::Срез{тип_элемента} => {
                        let [индекс] = &аргументы.выражения[..] else {
                            диагностика!(&аргументы.ключ.лок, "ОШИБКА", "Некорректная размерность среза. Ожидался 1 индекс, но повстречалось {ранк}", ранк = аргументы.выражения.len());
                            return Ошиб(());
                        };

                        пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(СРЕЗ_АДРЕС_СМЕЩЕНИЕ), лок: аргументы.ключ.лок.clone()});
                        пп.код.push(Инструкция{ вид: ВидИнструкции::НатСложение, лок: аргументы.ключ.лок.clone()});
                        пп.код.push(Инструкция{ вид: ВидИнструкции::Прочитать64, лок: аргументы.ключ.лок.clone()});
                        индексировать_массив(тип_элемента, пп, имена, текущая_процедура, локальные_имена, индекс, временный_размер)?;
                        if тип_элемента.примитивный() {
                            прочитать_примитивный_тип(&аргументы.ключ.лок, &mut пп.код, &имена.структуры, &тип_элемента)?;
                        }
                        тип_вызываемого = *тип_элемента.clone();
                    }
                    _ => {
                        диагностика!(&аргументы.ключ.лок, "ОШИБКА", "Невозможно индексировать тип «{тип}»", тип = тип_вызываемого.текст());
                        return Ошиб(())
                    }
                }
            }

            Хорош(тип_вызываемого)
        }

        Выражение::Отрицание{ключ, выражение} => {
            let тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, выражение, временный_размер)?;
            проверить_типы(&выражение.лок(), &Тип::Лог, &тип)?;
            пп.код.push(Инструкция{ вид: ВидИнструкции::ЛогОтрицание, лок: ключ.лок.clone() });
            Хорош(Тип::Лог)
        }
    }
}

fn достать_и_проверить_процедуру_печати<'ы>(имена: &'ы Имена, имя_принтера: &str, тип: &Тип, лок: &Лок) -> Результат<&'ы СкомпПроцедура> {
    if let Некий(процедура) = имена.процедуры.get(имя_принтера) {
        let арность = 1;
        let [параметр] = процедура.параметры.as_slice() else {
            диагностика!(лок, "ОШИБКА", "Процедура «{имя_принтера}» ответственная за печать данного аргумента типа «{тип}» имеет некорректную сигнатуру. Она должна принимать {арность} {параметров} типа «{тип}»", тип = тип.текст(), параметров = ЧИСУЩ_ПАРАМЕТР.текст(арность));
            диагностика!(&процедура.имя.лок, "ИНФО", "Но по факту, она принимает {число_параметров}", число_параметров = процедура.параметры.len());
            return Ошиб(());
        };
        if параметр.тип != *тип {
            диагностика!(лок, "ОШИБКА", "Процедура «{имя_принтера}» ответственная за печать данного аргумента типа «{тип}» имеет некорректную сигнатуру. Она должна принимать {арность} {параметров} типа «{тип}»", тип = тип.текст(), параметров = ЧИСУЩ_ПАРАМЕТР.текст(арность));
            диагностика!(&процедура.имя.лок, "ИНФО", "Но по факту, она принимает тип «{тип}»", тип = параметр.тип.текст());
            return Ошиб(());
        }
        if let Некий(результат) = &процедура.результат {
            диагностика!(лок, "ОШИБКА", "Процедура «{имя_принтера}» ответственная за печать данного аргумента типа «{тип}» имеет некорректную сигнатуру. Она не должна возвращать никаких результатов", тип = тип.текст());
            диагностика!(&процедура.имя.лок, "ИНФО", "Но по факту, она возвращает тип «{тип}»", тип = результат.тип.текст());
            return Ошиб(());
        }

        Хорош(процедура)
    } else {
        диагностика!(лок, "ОШИБКА", "Чтобы печатать значения типа «{тип}», нужно чтобы где-нибудь была определена процедура с именем «{имя_принтера}», которая принимает один аргумент типа «{тип}» и печатает его. Мы не смогли найти определение такой процедуры. Обычно все нужные процедуры печати определены в модуле «прелюдия». Возможно мы не смогли его загрузить.", тип = тип.текст());
        Ошиб(())
    }
}

fn вызвать_процедуру(лок: Лок, имена: &Имена, процедура: &СкомпПроцедура, код: &mut Vec<Инструкция>, временный_размер: &mut usize) -> Результат<()> {
    match &процедура.точка_входа {
        &ТочкаВхода::Внутреняя{адрес} => {
            код.push(Инструкция {
                вид: ВидИнструкции::ВнутреннийВызов(адрес),
                лок: лок.clone(),
            });
            if let Некий(результат) = &процедура.результат {
                if !результат.тип.примитивный() {
                    *временный_размер += результат.тип.размер(&имена.структуры);
                }
            }
        },
        &ТочкаВхода::Внешняя{индекс} => {
            for параметр in &процедура.параметры {
                if параметр.тип != Тип::Нат64 && параметр.тип != Тип::Цел64 {
                    сделать!(&лок, "Вызов внешней процедуры с параметрами типа «{тип}»", тип = параметр.тип.текст());
                    return Ошиб(())
                }
            }

            код.push(Инструкция {
                вид: ВидИнструкции::ВнешнийВызов{
                    индекс,
                    арность: процедура.параметры.len(),
                    результат: процедура.результат.clone().map(|результат| результат.тип),
                },
                лок,
            });
        },
    }
    Хорош(())
}

fn индексировать_массив(тип_элемента: &Тип, пп: &mut ПП, имена: &Имена, текущая_процедура: &СкомпПроцедура, локальные_имена: &ЛокальныеИмена, индекс: &Выражение, временный_размер: &mut usize) -> Результат<()> {
    // СДЕЛАТЬ: проверку входа за границы массива/среза. Включая отрицательные числа.
    let тип_индекса = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, индекс, временный_размер)?;
    match тип_индекса {
        Тип::Нат64 => {
            пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(тип_элемента.размер(&имена.структуры)), лок: индекс.лок().clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::НатУмножение, лок: индекс.лок().clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::НатСложение, лок: индекс.лок().clone() });
            Хорош(())
        }
        Тип::Цел64 => {
            пп.код.push(Инструкция{ вид: ВидИнструкции::Целое(тип_элемента.размер(&имена.структуры) as i64), лок: индекс.лок().clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелУмножение, лок: индекс.лок().clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::НатСложение, лок: индекс.лок().clone() });
            Хорош(())
        }
        _ => {
            диагностика!(индекс.лок(), "ОШИБКА", "Невозможно индексировать массивы типом «{тип}»", тип = тип_индекса.текст());
            Ошиб(())
        }
    }
}

enum Локация {
    Глобальная,
    Стековая,
}

impl Локация {
    fn протолкнуть_смещение(&self, пп: &mut ПП, лок: &Лок, смещение: i32) {
        match self {
            Локация::Глобальная => {
                пп.заплатки_неиниц_указателей.push(пп.код.len());
                пп.код.push(Инструкция{ вид: ВидИнструкции::ГлобальныеДанные(смещение), лок: лок.clone() });
            }
            Локация::Стековая => {
                пп.код.push(Инструкция{ вид: ВидИнструкции::Кадр(смещение), лок: лок.clone() });
            }
        }
    }
}

fn найти_константу_по_имени<'ы>(имя: &str, имена: &'ы Имена, локальные_имена: Опция<&'ы ЛокальныеИмена>) -> Опция<&'ы СкомпКонстанта> {
    if let Некий(локальные_имена) = локальные_имена {
        if let Некий(константа) = локальные_имена.найти_константу_по_имени(имя) {
            return Некий(константа);
        }
    }

    if let Некий(константа) = имена.константы.get(имя) {
        return Некий(константа);
    }

    Нету
}

fn найти_переменную_по_имени<'ы>(имя: &str, имена: &'ы Имена, текущая_процедура: &'ы СкомпПроцедура, локальные_имена: &'ы ЛокальныеИмена) -> Опция<(&'ы СкомпПеременная, Локация)> {
    if let Некий(переменная) = локальные_имена.найти_переменную_по_имени(имя) {
        return Некий((переменная, Локация::Стековая));
    }

    if let Некий(параметр) = текущая_процедура.параметры.iter().find(|параметр| параметр.имя.текст == имя) {
        return Некий((параметр, Локация::Стековая));
    }

    if let Некий(переменная) = имена.переменные.get(имя) {
        return Некий((переменная, Локация::Глобальная));
    }

    Нету
}

/// Левое выражение - это выражение по левой стороне от присваивания:
///
/// <левое> := <правое>;
///
/// Особенность левых выражений в том, что они являются ссылками.
fn скомпилировать_левое_выражение(пп: &mut ПП, имена: &Имена, текущая_процедура: &СкомпПроцедура, локальные_имена: &ЛокальныеИмена, выражение: &Выражение, временный_размер: &mut usize) -> Результат<Тип> {
    match выражение {
        Выражение::Лог(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Логическое выражение не может находиться в левой части присваивания");
            Ошиб(())
        }
        Выражение::ЦелЧисло(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Целое число не может находиться в левой части присваивания");
            Ошиб(())
        }
        Выражение::НатЧисло(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Натуральное число не может находиться в левой части присваивания");
            Ошиб(())
        }
        Выражение::ВещЧисло(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Вещественное число не может находиться в левой части присваивания");
            Ошиб(())
        }
        Выражение::Строка(лексема) => {
            // А мы точно хотим разрешать подобные вещи?
            сделать!(&лексема.лок, "Присваивание строковых литералов");
            Ошиб(())
        }
        Выражение::Идент(имя) => {
            if let Некий((переменная, локация)) = найти_переменную_по_имени(&имя.текст, имена, текущая_процедура, локальные_имена) {
                локация.протолкнуть_смещение(пп, &имя.лок, переменная.смещение);
                return Хорош(переменная.тип.clone());
            }

            if let Некий(_) = найти_константу_по_имени(&имя.текст, имена, Некий(локальные_имена)) {
                диагностика!(&имя.лок, "ОШИБКА", "Константы не могут находиться в данном месте");
                return Ошиб(());
            }

            диагностика!(&имя.лок, "ОШИБКА", "Неизвестная переменная «{имя}»", имя = имя.текст);
            Ошиб(())
        }
        Выражение::ЦепочкаВызовов{имя, цепочка_аргументов} => {
            let mut тип = if let Некий((переменная, локация)) = найти_переменную_по_имени(&имя.текст, имена, текущая_процедура, локальные_имена) {
                локация.протолкнуть_смещение(пп, &имя.лок, переменная.смещение);
                переменная.тип.clone()
            } else if let Некий(_) = найти_константу_по_имени(&имя.текст, имена, Некий(локальные_имена)) {
                диагностика!(&имя.лок, "ОШИБКА", "Константы не могут находиться в данном месте.");
                return Ошиб(());
            } else {
                // СДЕЛАТЬ: Капитализировать все сообщения диагностики и заверщить их точкой в конце.
                диагностика!(&имя.лок, "ОШИБКА", "Переменной с именем «{имя}» не существует.", имя = имя.текст);
                return Ошиб(())
            };

            for аргументы in цепочка_аргументов.iter() {
                match &тип {
                    Тип::Массив{тип_элемента, ..} => {
                        if аргументы.выражения.len() != 1 {
                            диагностика!(&имя.лок, "ОШИБКА", "Некорректная размерность массива. Ожидался 1 индекс, но повстречалось {ранк}", ранк = аргументы.выражения.len());
                            return Ошиб(());
                        };
                        let индекс = &аргументы.выражения[0];
                        индексировать_массив(&*тип_элемента, пп, имена, текущая_процедура, локальные_имена, индекс, временный_размер)?;
                        тип = *тип_элемента.clone();
                    }
                    Тип::Срез{тип_элемента} => {
                        if аргументы.выражения.len() != 1 {
                            диагностика!(&имя.лок, "ОШИБКА", "Некорректная размерность среза. Ожидался 1 индекс, но повстречалось {ранк}", ранк = аргументы.выражения.len());
                            return Ошиб(());
                        };
                        let индекс = &аргументы.выражения[0];
                        пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(СРЕЗ_АДРЕС_СМЕЩЕНИЕ), лок: имя.лок.clone()});
                        пп.код.push(Инструкция{ вид: ВидИнструкции::НатСложение, лок: имя.лок.clone()});
                        пп.код.push(Инструкция{ вид: ВидИнструкции::Прочитать64, лок: имя.лок.clone()});
                        индексировать_массив(&*тип_элемента, пп, имена, текущая_процедура, локальные_имена, индекс, временный_размер)?;
                        тип = *тип_элемента.clone();
                    }
                    _ => {
                        диагностика!(&имя.лок, "ОШИБКА", "Не возможно индексировать переменные тип «{тип}»", тип = тип.текст());
                        return Ошиб(());
                    }
                }
            }
            Хорош(тип)
        }
        Выражение::УнарныйМинус{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Унарный минус не может находится в левой части присваивания");
            Ошиб(())
        }
        Выражение::Биноп{ключ, вид, левое, правое} => {
            if let ВидБинопа::Поле = вид {
                let левый_тип = скомпилировать_левое_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                match &**правое {
                    Выражение::Идент(имя_поля) => {
                        match &левый_тип {
                            Тип::Структура(имя_структуры) => {
                                let структура = имена
                                    .структуры
                                    .get(имя_структуры)
                                    .expect("Существование структуры должно быть уже проверено на этапе компиляции типа");
                                if let Некий(поле) = структура.поля.get(&имя_поля.текст) {
                                    пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(поле.смещение), лок: ключ.лок.clone() });
                                    пп.код.push(Инструкция{ вид: ВидИнструкции::НатСложение, лок: ключ.лок.clone() });
                                    Хорош(поле.тип.clone())
                                } else {
                                    диагностика!(&ключ.лок, "ОШИБКА", "У структуры «{тип}» отстутствует поле «{поле}»", тип = левый_тип.текст(), поле = имя_поля.текст);
                                    Ошиб(())
                                }
                            }
                            _ => {
                                диагностика!(&ключ.лок, "ОШИБКА", "У типа «{тип}» отстутствует поле «{поле}»", тип = левый_тип.текст(), поле = имя_поля.текст);
                                Ошиб(())
                            }
                        }
                    }
                    Выражение::ЦепочкаВызовов{имя: имя_поля, цепочка_аргументов} => {
                        let mut тип = match &левый_тип {
                            Тип::Структура(имя_структуры) => {
                                let структура = имена
                                    .структуры
                                    .get(имя_структуры)
                                    .expect("Существование структуры должно быть уже проверено на этапе компиляции типа");
                                if let Некий(поле) = структура.поля.get(&имя_поля.текст) {
                                    пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(поле.смещение), лок: ключ.лок.clone() });
                                    пп.код.push(Инструкция{ вид: ВидИнструкции::НатСложение, лок: ключ.лок.clone() });
                                    поле.тип.clone()
                                } else {
                                    диагностика!(&ключ.лок, "ОШИБКА", "У структуры «{тип}» отстутствует поле «{поле}»", тип = левый_тип.текст(), поле = имя_поля.текст);
                                    return Ошиб(());
                                }
                            }
                            _ => {
                                диагностика!(&ключ.лок, "ОШИБКА", "У типа «{тип}» отстутствует поле «{поле}»", тип = левый_тип.текст(), поле = имя_поля.текст);
                                return Ошиб(());
                            }
                        };

                        for аргументы in цепочка_аргументов.iter() {
                            match &тип {
                                Тип::Массив{тип_элемента, ..} => {
                                    if аргументы.выражения.len() != 1 {
                                        диагностика!(&имя_поля.лок, "ОШИБКА", "Некорректная размерность массива. Ожидался 1 индекс, но повстречалось {ранк}", ранк = аргументы.выражения.len());
                                        return Ошиб(());
                                    };
                                    let индекс = &аргументы.выражения[0];
                                    индексировать_массив(&*тип_элемента, пп, имена, текущая_процедура, локальные_имена, индекс, временный_размер)?;
                                    тип = *тип_элемента.clone();
                                }
                                Тип::Срез{тип_элемента} => {
                                    if аргументы.выражения.len() != 1 {
                                        диагностика!(&имя_поля.лок, "ОШИБКА", "Некорректная размерность массива. Ожидался 1 индекс, но повстречалось {ранк}", ранк = аргументы.выражения.len());
                                        return Ошиб(());
                                    };

                                    let индекс = &аргументы.выражения[0];
                                    пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(СРЕЗ_АДРЕС_СМЕЩЕНИЕ), лок: имя_поля.лок.clone()});
                                    пп.код.push(Инструкция{ вид: ВидИнструкции::НатСложение, лок: имя_поля.лок.clone()});
                                    пп.код.push(Инструкция{ вид: ВидИнструкции::Прочитать64, лок: имя_поля.лок.clone()});
                                    индексировать_массив(&*тип_элемента, пп, имена, текущая_процедура, локальные_имена, индекс, временный_размер)?;
                                    тип = *тип_элемента.clone();
                                }
                                _ => {
                                    диагностика!(&имя_поля.лок, "ОШИБКА", "Не возможно индексировать переменные тип «{тип}»", тип = тип.текст());
                                    return Ошиб(());
                                }
                            }
                        }

                        Хорош(тип)
                    }
                    _ => {
                        диагностика!(&правое.лок(), "ОШИБКА", "Данное выражение не может быть использовано как поле");
                        Ошиб(())
                    }
                }
            } else {
                диагностика!(&ключ.лок, "ОШИБКА", "Данная бинарная операция не может находиться в левой части присваивания");
                Ошиб(())
            }
        }
        Выражение::Отрицание{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Отрицание не может находится в левой части присваивания");
            Ошиб(())
        }
    }
}

fn записать_тип(лок: &Лок, код: &mut Vec<Инструкция>, структуры: &HashMap<String, Структура>, тип: &Тип) -> Результат<()> {
    if тип.примитивный() {
        записать_примитивный_тип(лок, код, тип.размер(структуры))?;
    } else {
        код.push(Инструкция{ вид: ВидИнструкции::Натуральное(тип.размер(структуры)), лок: лок.clone() });
        код.push(Инструкция{ вид: ВидИнструкции::СкопироватьПамять, лок: лок.clone() });
    }
    Хорош(())
}

fn скомпилировать_утверждение(пп: &mut ПП, имена: &Имена, текущая_процедура: &СкомпПроцедура, локальные_имена: &mut ЛокальныеИмена, утверждение: &Утверждение, отложенные_возвраты: &mut Vec<usize>) -> Результат<()> {
    match утверждение {
        Утверждение::Присваивание{ключ, левое, правое} => {
            let mut временный_размер = 0;
            let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, правое, &mut временный_размер)?;
            let левый_тип = скомпилировать_левое_выражение(пп, имена, текущая_процедура, локальные_имена, левое, &mut временный_размер)?;
            проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
            записать_тип(&ключ.лок, &mut пп.код, &имена.структуры, &левый_тип)?;
            if временный_размер > 0 {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер as u64), лок: ключ.лок.clone() })
            }
            Хорош(())
        }
        Утверждение::Выражение{выражение} => {
            match выражение {
                Выражение::ЦепочкаВызовов{имя, цепочка_аргументов} => {
                    match &цепочка_аргументов.as_slice() {
                        &[] => unreachable!("Цепочка вызовов должна содержать как минимум один набор аргументов. Если это не так, то это баг разбора кода"),
                        &[аргументы] => {
                            скомпилировать_утверждение_вызова_функции_по_имени(пп, имена, текущая_процедура, локальные_имена, имя, &аргументы.выражения)?;
                            Хорош(())
                        },
                        _ => {
                            диагностика!(&имя.лок, "ОШИБКА", "Цепочки вызовов в контексте утверждений пока не имеют особого смысла, т.к. возвращать функции мы пока не умеем, а с массивами и срезами в контексте утверждений ничего полезного сделать все равно нельзя.");
                            return Ошиб(());
                        }
                    }
                }
                _ => {
                    диагностика!(выражение.лок(), "ОШИБКА", "Подобные выражения в контексте утверждений не возможны. Можно только вызывать функции, которые не возвращают аргументов");
                    Ошиб(())
                }
            }
        }
        Утверждение::Если{ключ, условие, тело, иначе} => {
            let mut временный_размер = 0;
            let тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &условие, &mut временный_размер)?;
            проверить_типы(&условие.лок(), &Тип::Лог, &тип)?;
            пп.код.push(Инструкция{ вид: ВидИнструкции::ЛогОтрицание, лок: ключ.лок.clone() });
            if временный_размер > 0 {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер as u64), лок: ключ.лок.clone() });
            }
            let точка_условного_прыжка = пп.код.len();
            пп.код.push(Инструкция{ вид: ВидИнструкции::Ноп, лок: ключ.лок.clone() });

            локальные_имена.стек_областей.push(Default::default());
            for утверждение in тело.iter() {
                скомпилировать_утверждение(пп, имена, текущая_процедура, локальные_имена, утверждение, отложенные_возвраты)?;
            }
            let размер_области = локальные_имена
                .стек_областей
                .pop()
                .expect("Тело условия «если» не трогает область которую мы протолкнули")
                .размер_переменных_на_стеке;
            if размер_области > 0 {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_области as u64), лок: ключ.лок.clone() });
            }


            if иначе.len() == 0 {
                let точка_выхода = пп.код.len();
                пп.код[точка_условного_прыжка].вид = ВидИнструкции::УсловныйПрыжок(точка_выхода);
            } else {
                let точка_конца_тела = пп.код.len();
                пп.код.push(Инструкция{ вид: ВидИнструкции::Ноп, лок: ключ.лок.clone() });

                let точка_иначе = пп.код.len();
                пп.код[точка_условного_прыжка].вид = ВидИнструкции::УсловныйПрыжок(точка_иначе);

                локальные_имена.стек_областей.push(Default::default());
                for утверждение in иначе.iter() {
                    скомпилировать_утверждение(пп, имена, текущая_процедура, локальные_имена, утверждение, отложенные_возвраты)?;
                }
                let размер_области = локальные_имена
                    .стек_областей
                    .pop()
                    .expect("Тело условия «если» не трогает область которую мы протолкнули")
                    .размер_переменных_на_стеке;
                if размер_области > 0 {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_области as u64), лок: ключ.лок.clone() });
                }

                let точка_выхода = пп.код.len();
                пп.код[точка_конца_тела].вид = ВидИнструкции::Прыжок(точка_выхода);
            }
            Хорош(())
        }
        Утверждение::Вернуть{ключ, выражение} => {
            if let Некий(выражение) = выражение {
                if let Некий(результат) = &текущая_процедура.результат {
                    let mut временный_размер = 0;
                    let тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &выражение, &mut временный_размер)?;
                    проверить_типы(&выражение.лок(), &результат.тип, &тип)?;
                    пп.код.push(Инструкция{ вид: ВидИнструкции::Кадр(результат.смещение_от_кадра), лок: ключ.лок.clone() });
                    записать_тип(&ключ.лок, &mut пп.код, &имена.структуры, &тип)?;
                    let размер_всех_локальных_переменных = локальные_имена
                        .стек_областей
                        .iter()
                        .map(|область| область.размер_переменных_на_стеке)
                        .sum::<usize>();
                    if временный_размер + размер_всех_локальных_переменных > 0 {
                        пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека((временный_размер + размер_всех_локальных_переменных) as u64), лок: выражение.лок().clone() });
                    }
                } else {
                    диагностика!(выражение.лок(), "ОШИБКА", "Процедура не возвращает никаких значений");
                    return Ошиб(());
                }
            } else {
                if let Некий(результат) = &текущая_процедура.результат {
                    диагностика!(&ключ.лок, "ОШИБКА", "Процедура возвращает значение типа «{тип}»", тип = результат.тип.текст());
                    return Ошиб(());
                }
            }
            отложенные_возвраты.push(пп.код.len());
            пп.код.push(Инструкция{ вид: ВидИнструкции::Прыжок(0), лок: ключ.лок.clone() });
            Хорош(())
        }
        Утверждение::Пока{ключ, условие, тело} => {
            let точка_условия = пп.код.len();
            let mut временный_размер = 0;
            let тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &условие, &mut временный_размер)?;
            проверить_типы(&условие.лок(), &Тип::Лог, &тип)?;
            пп.код.push(Инструкция{ вид: ВидИнструкции::ЛогОтрицание, лок: ключ.лок.clone() });
            if временный_размер > 0 {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер as u64), лок: ключ.лок.clone() });
            }
            let точка_условного_прыжка = пп.код.len();

            пп.код.push(Инструкция{ вид: ВидИнструкции::Ноп, лок: ключ.лок.clone() });
            локальные_имена.стек_областей.push(Default::default());
            for утверждение in тело.iter() {
                скомпилировать_утверждение(пп, имена, текущая_процедура, локальные_имена, утверждение, отложенные_возвраты)?;
            }
            let размер_области = локальные_имена
                .стек_областей
                .pop()
                .expect("Тело цикла «пока» не трогает область которую мы протолкнули")
                .размер_переменных_на_стеке;
            if размер_области > 0 {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_области as u64), лок: ключ.лок.clone() });
            }

            пп.код.push(Инструкция{ вид: ВидИнструкции::Прыжок(точка_условия), лок: ключ.лок.clone() });
            let точка_выхода = пп.код.len();
            пп.код[точка_условного_прыжка].вид = ВидИнструкции::УсловныйПрыжок(точка_выхода);
            Хорош(())
        }
        Утверждение::Для{ключ, индекс, нижняя_граница, верхняя_граница, тело} => {
            локальные_имена.стек_областей.push(Default::default());

            let размер_всех_локальных_переменных = локальные_имена
                .стек_областей
                .iter()
                .map(|область| область.размер_переменных_на_стеке)
                .sum::<usize>();

            let тип_переменной = Тип::Цел64;
            let размер = выравнять_размер_по_слову(тип_переменной.размер(&имена.структуры));
            пп.код.push(Инструкция{ вид: ВидИнструкции::ВыделитьНаСтеке(размер as u64), лок: ключ.лок.clone() });
            let смещение =
                -(2*(РАЗМЕР_СЛОВА as i32))                  // пропускаем кадр и адрес возврата
                -(размер as i32)                            // сама переменная
                -(размер_всех_локальных_переменных as i32); // пропускаем все предыдущие локальные переменные

            let текущая_область_видимости = локальные_имена
                .стек_областей
                .last_mut()
                .expect("Компиляция процедуры обязана создать хотя бы одну область видимости");

            // СДЕЛАТЬ: Проверка затенения имен локальными переменными.
            if let Некий(существующая_переменная) = текущая_область_видимости.переменные.get(&индекс.текст) {
                диагностика!(&индекс.лок, "ОШИБКА", "Переопределение локальной переменной «{имя}»", имя = индекс.текст);
                диагностика!(&существующая_переменная.имя.лок, "ИНФО", "Первое определение находится здесь");
                return Ошиб(());
            }
            текущая_область_видимости.переменные.insert(индекс.текст.clone(), СкомпПеременная {
                имя: индекс.clone(),
                тип: тип_переменной,
                смещение
            });
            текущая_область_видимости.размер_переменных_на_стеке += размер;

            if let Некий((переменная, локация)) = найти_переменную_по_имени(&индекс.текст, имена, текущая_процедура, локальные_имена) {
                проверить_типы(&индекс.лок, &Тип::Цел64, &переменная.тип)?;

                // Инициализация индексной переменной
                let mut временный_размер = 0;
                let тип_нижней_границы = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &нижняя_граница, &mut временный_размер)?;
                проверить_типы(&нижняя_граница.лок(), &переменная.тип, &тип_нижней_границы)?;
                локация.протолкнуть_смещение(пп, &индекс.лок, переменная.смещение);
                записать_тип(&индекс.лок, &mut пп.код, &имена.структуры, &переменная.тип)?;
                if временный_размер > 0 {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер as u64), лок: ключ.лок.clone() });
                    временный_размер = 0;
                }

                // Проверка условия выхода из цикла
                let точка_условия = пп.код.len();
                локация.протолкнуть_смещение(пп, &индекс.лок, переменная.смещение);
                прочитать_примитивный_тип(&индекс.лок, &mut пп.код, &имена.структуры, &переменная.тип)?;
                let тип_верхней_границы = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &верхняя_граница, &mut временный_размер)?;
                проверить_типы(&верхняя_граница.лок(), &переменная.тип, &тип_верхней_границы)?;
                пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелБольше, лок: ключ.лок.clone() });
                let точка_условного_прыжка = пп.код.len();
                пп.код.push(Инструкция{ вид: ВидИнструкции::Ноп, лок: ключ.лок.clone() });
                if временный_размер > 0 {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер as u64), лок: ключ.лок.clone() });
                }

                let переменная_тип = переменная.тип.clone();
                let переменная_смещение = переменная.смещение;

                // Тело
                локальные_имена.стек_областей.push(Default::default());
                for утверждение in тело.iter() {
                    скомпилировать_утверждение(пп, имена, текущая_процедура, локальные_имена, утверждение, отложенные_возвраты)?;
                }
                let размер_области = локальные_имена
                    .стек_областей
                    .pop()
                    .expect("Тело цикла «для» не трогает область которую мы протолкнули")
                    .размер_переменных_на_стеке;
                if размер_области > 0 {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_области as u64), лок: ключ.лок.clone() });
                }

                // Инкремент
                локация.протолкнуть_смещение(пп, &индекс.лок, переменная_смещение);
                прочитать_примитивный_тип(&индекс.лок, &mut пп.код, &имена.структуры, &переменная_тип)?;
                пп.код.push(Инструкция{ вид: ВидИнструкции::Натуральное(1), лок: ключ.лок.clone() });
                пп.код.push(Инструкция{ вид: ВидИнструкции::НатСложение, лок: ключ.лок.clone() });
                локация.протолкнуть_смещение(пп, &индекс.лок, переменная_смещение);
                записать_тип(&индекс.лок, &mut пп.код, &имена.структуры, &переменная_тип)?;


                пп.код.push(Инструкция{ вид: ВидИнструкции::Прыжок(точка_условия), лок: ключ.лок.clone() });
                let точка_выхода = пп.код.len();
                пп.код[точка_условного_прыжка].вид = ВидИнструкции::УсловныйПрыжок(точка_выхода);

                let размер_области = локальные_имена
                    .стек_областей
                    .pop()
                    .expect("Тело цикла «для» не трогает область которую мы протолкнули")
                    .размер_переменных_на_стеке;
                if размер_области > 0 {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_области as u64), лок: ключ.лок.clone() });
                }

                return Хорош(())
            }

            диагностика!(&индекс.лок, "ОШИБКА", "Неизвестная переменная «{имя}»", имя = индекс.текст);
            Ошиб(())
        }
        Утверждение::ДекларацияПеременной{ключ, имя, тип, значение} => {
            let размер_всех_локальных_переменных = локальные_имена
                .стек_областей
                .iter()
                .map(|область| область.размер_переменных_на_стеке)
                .sum::<usize>();

            let тип_переменной = скомпилировать_тип(пп, тип, имена, Некий(локальные_имена))?;
            let размер = выравнять_размер_по_слову(тип_переменной.размер(&имена.структуры));
            пп.код.push(Инструкция{ вид: ВидИнструкции::ВыделитьНаСтеке(размер as u64), лок: ключ.лок.clone() });
            let смещение =
                -(2*(РАЗМЕР_СЛОВА as i32))                  // пропускаем кадр и адрес возврата
                -(размер as i32)                            // сама переменная
                -(размер_всех_локальных_переменных as i32); // пропускаем все предыдущие локальные переменные

            if let Некий(значение) = значение {
                let mut временный_размер = 0;
                let тип_значения = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, значение, &mut временный_размер)?;
                проверить_типы(&значение.лок(), &тип_переменной, &тип_значения)?;
                пп.код.push(Инструкция{ вид: ВидИнструкции::Кадр(смещение), лок: ключ.лок.clone() });
                записать_тип(&ключ.лок, &mut пп.код, &имена.структуры, &тип_переменной)?;
                if временный_размер > 0 {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер as u64), лок: ключ.лок.clone() });
                }
            }

            let текущая_область_видимости = локальные_имена
                .стек_областей
                .last_mut()
                .expect("Компиляция процедуры обязана создать хотя бы одну область видимости");
            // СДЕЛАТЬ: Проверка затенения имен локальными переменными.
            if let Некий(существующая_переменная) = текущая_область_видимости.переменные.get(&имя.текст) {
                диагностика!(&имя.лок, "ОШИБКА", "Переопределение локальной переменной «{имя}»", имя = имя.текст);
                диагностика!(&существующая_переменная.имя.лок, "ИНФО", "Первое определение находится здесь");
                return Ошиб(());
            }
            текущая_область_видимости.переменные.insert(имя.текст.clone(), СкомпПеременная {
                имя: имя.clone(),
                тип: тип_переменной,
                смещение
            });
            текущая_область_видимости.размер_переменных_на_стеке += размер;

            Хорош(())
        }
        Утверждение::ДекларацияКонстанты{имя, значение, ..} => {
            let (байты_значения, тип) = скомпилировать_константное_выражение(пп, имена, Некий(локальные_имена), значение)?;

            let текущая_область_видимости = локальные_имена
                .стек_областей
                .last_mut()
                .expect("Компиляция процедуры обязана создать хотя бы одну область видимости");
            // СДЕЛАТЬ: Проверка затенения имен локальными константами.
            if let Некий(существующая_константа) = текущая_область_видимости.константы.get(&имя.текст) {
                диагностика!(&имя.лок, "ОШИБКА", "Переопределение локальной константы «{имя}»", имя = имя.текст);
                диагностика!(&существующая_константа.имя.лок, "ИНФО", "Первое определение находится здесь");
                return Ошиб(());
            }

            if тип.примитивный() {
                let значение = u64::from_le_bytes(байты_значения.as_slice().try_into().unwrap());
                текущая_область_видимости.константы.insert(имя.текст.clone(), СкомпКонстанта {
                    имя: имя.clone(),
                    тип,
                    значение_или_адрес: значение,
                });
            } else {
                let адрес = пп.иниц_данные.len();
                пп.иниц_данные.extend(байты_значения);

                текущая_область_видимости.константы.insert(имя.текст.clone(), СкомпКонстанта {
                    имя: имя.clone(),
                    тип,
                    значение_или_адрес: адрес as u64,
                });
            }

            Хорош(())
        }
        Утверждение::Вилка{ключ, выражение, ветки, любое} => {
            let mut временный_размер_корня: usize = 0;
            let тип_корня = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, выражение, &mut временный_размер_корня)?;
            if !тип_корня.примитивный() {
                // СДЕЛАТЬ: вилка для сложных типов
                диагностика!(выражение.лок(), "ОШИБКА", "Использовать вилку пока что можно только для примитивных типов");
                return Ошиб(());
            }
            let mut прыжки_в_конец = Vec::new();
            for ветка in ветки {
                пп.код.push(Инструкция{ вид: ВидИнструкции::Продублировать, лок: выражение.лок().clone() });
                let mut временный_размер_ветки: usize = 0;
                let тип_ветки = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &ветка.выражение, &mut временный_размер_ветки)?;
                проверить_типы(ветка.выражение.лок(), &тип_корня, &тип_ветки)?;
                пп.код.push(Инструкция{ вид: ВидИнструкции::НатРавно, лок: ветка.ключ.лок.clone() });
                пп.код.push(Инструкция{ вид: ВидИнструкции::ЛогОтрицание, лок: ветка.ключ.лок.clone() });
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер_ветки as u64), лок: ветка.ключ.лок.clone() });
                let прыжок_на_следующую_ветку = пп.код.len();
                пп.код.push(Инструкция{ вид: ВидИнструкции::УсловныйПрыжок(0), лок: ветка.ключ.лок.clone() });

                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер_корня as u64), лок: ветка.ключ.лок.clone() });
                пп.код.push(Инструкция{ вид: ВидИнструкции::Вытолкнуть, лок: ветка.ключ.лок.clone() });

                локальные_имена.стек_областей.push(Default::default());
                for утверждение in ветка.тело.iter() {
                    скомпилировать_утверждение(пп, имена, текущая_процедура, локальные_имена, утверждение, отложенные_возвраты)?;
                }
                let размер_области = локальные_имена
                    .стек_областей
                    .pop()
                    .expect("Тело ветки вилки не трогает область которую мы протолкнули")
                    .размер_переменных_на_стеке;
                if размер_области > 0 {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_области as u64), лок: ветка.ключ.лок.clone() });
                }

                прыжки_в_конец.push(пп.код.len());
                пп.код.push(Инструкция{ вид: ВидИнструкции::Прыжок(0), лок: ветка.ключ.лок.clone() });

                let следующая_ветка = пп.код.len();
                if let ВидИнструкции::УсловныйПрыжок(адрес) = &mut пп.код[прыжок_на_следующую_ветку].вид {
                    *адрес = следующая_ветка;
                } else {
                    unreachable!();
                }
            }
            пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер_корня as u64), лок: ключ.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::Вытолкнуть, лок: ключ.лок.clone() });

            if let Некий((любое_ключ, любое_тело)) = любое {
                локальные_имена.стек_областей.push(Default::default());
                for утверждение in любое_тело.iter() {
                    скомпилировать_утверждение(пп, имена, текущая_процедура, локальные_имена, утверждение, отложенные_возвраты)?;
                }
                let размер_области = локальные_имена
                    .стек_областей
                    .pop()
                    .expect("Тело ветки вилки не трогает область которую мы протолкнули")
                    .размер_переменных_на_стеке;
                if размер_области > 0 {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_области as u64), лок: любое_ключ.лок.clone() });
                }
            }

            let конец_вилки = пп.код.len();
            for прыжок in прыжки_в_конец {
                if let ВидИнструкции::Прыжок(адрес) = &mut пп.код[прыжок].вид {
                    *адрес = конец_вилки;
                } else {
                    unreachable!();
                }
            }

            Хорош(())
        }
    }
}

fn выравнять_размер_по_слову(размер: usize) -> usize {
    (размер + РАЗМЕР_СЛОВА - 1)/РАЗМЕР_СЛОВА*РАЗМЕР_СЛОВА
}

fn записать_примитивный_тип(лок: &Лок, код: &mut Vec<Инструкция>, размер: usize) -> Результат<()> {
    match размер {
        1 => код.push(Инструкция{ вид: ВидИнструкции::Записать8, лок: лок.clone() }),
        2 => код.push(Инструкция{ вид: ВидИнструкции::Записать16, лок: лок.clone() }),
        4 => код.push(Инструкция{ вид: ВидИнструкции::Записать32, лок: лок.clone() }),
        8 => код.push(Инструкция{ вид: ВидИнструкции::Записать64, лок: лок.clone() }),
        размер => unreachable!("Примитивных типов размера {} нет", размер),
    }
    Хорош(())
}

fn прочитать_примитивный_тип(лок: &Лок, код: &mut Vec<Инструкция>, структуры: &HashMap<String, Структура>, тип: &Тип) -> Результат<()> {
    if let Некий(знаковое) = тип.примитивное_знаковое_чтение() {
        let размер = тип.размер(структуры);
        if знаковое {
            match размер {
                1 => код.push(Инструкция{ вид: ВидИнструкции::ПрочитатьЗнак8, лок: лок.clone() }),
                2 => код.push(Инструкция{ вид: ВидИнструкции::ПрочитатьЗнак16, лок: лок.clone() }),
                4 => код.push(Инструкция{ вид: ВидИнструкции::ПрочитатьЗнак32, лок: лок.clone() }),
                8 => код.push(Инструкция{ вид: ВидИнструкции::Прочитать64, лок: лок.clone() }),
                размер => unreachable!("Примитивных типов размера {} нет", размер),
            }
        } else {
            match размер {
                1 => код.push(Инструкция{ вид: ВидИнструкции::ПрочитатьБезЗнак8, лок: лок.clone() }),
                2 => код.push(Инструкция{ вид: ВидИнструкции::ПрочитатьБезЗнак16, лок: лок.clone() }),
                4 => код.push(Инструкция{ вид: ВидИнструкции::ПрочитатьБезЗнак32, лок: лок.clone() }),
                8 => код.push(Инструкция{ вид: ВидИнструкции::Прочитать64, лок: лок.clone() }),
                размер => unreachable!("Примитивных типов размера {} нет", размер),
            }
        }
        Хорош(())
    } else {
        unreachable!("Непримитивный тип")
    }
}


fn скомпилировать_процедуру(пп: &mut ПП, имена: &mut Имена, процедура: Процедура) -> Результат<()> {
    let mut параметры = Vec::new();
    let mut размер_параметров_на_стеке: usize = 0;

    for параметр in &процедура.параметры {
        let тип = скомпилировать_тип(пп, &параметр.тип, имена, Нету)?;
        let скомп_параметр = СкомпПеременная {
            имя: параметр.имя.clone(),
            тип,
            смещение: размер_параметров_на_стеке as i32,
        };
        размер_параметров_на_стеке += выравнять_размер_по_слову(скомп_параметр.тип.размер(&имена.структуры));
        параметры.push(скомп_параметр);
    }
    let результат = if let Некий(тип) = процедура.тип_результата {
        let результат = РезультатСкомпПроцедуры {
            тип: скомпилировать_тип(пп, &тип, имена, Нету)?,
            смещение_от_кадра: размер_параметров_на_стеке as i32,
        };
        размер_параметров_на_стеке += выравнять_размер_по_слову(результат.тип.размер(&имена.структуры));
        Некий(результат)
    } else {
        Нету
    };
    match процедура.тело {
        ТелоПроцедуры::Внутренее{блок} => {
            let адрес = пп.код.len();
            let скомп_процедура = СкомпПроцедура{
                имя: процедура.имя.clone(),
                параметры,
                точка_входа: ТочкаВхода::Внутреняя{адрес},
                результат,
            };

            if let Некий(_) = имена.процедуры.insert(скомп_процедура.имя.текст.clone(), скомп_процедура) {
                unreachable!("Проверка переопределения процедур должна происходить на этапе разбора")
            }

            let скомп_процедура = имена.процедуры.get(&процедура.имя.текст).unwrap();

            // СДЕЛАТЬ: Если размер_параметров_на_стеке равен 0, то, наверное, не имеет никакого смысла вообще включать данную инструкцию
            // Тоже самое можно сказать и про противоположную инструкцию ОсвободитьСоВторогоСтека.
            пп.код.push(Инструкция{ вид: ВидИнструкции::ВыделитьНаСтеке(размер_параметров_на_стеке as u64), лок: процедура.имя.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::СохранитьКадр, лок: процедура.имя.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::АргументНаСтек, лок: процедура.имя.лок.clone() }); // сохраняем адрес возврата на второй стек
            for параметр in скомп_процедура.параметры.iter() {
                пп.код.push(Инструкция{ вид: ВидИнструкции::Кадр(параметр.смещение), лок: параметр.имя.лок.clone() });
                записать_тип(&параметр.имя.лок, &mut пп.код, &имена.структуры, &параметр.тип)?;
            }
            let mut отложенные_возвраты = Vec::new();
            let mut локальные_имена = ЛокальныеИмена::default();
            локальные_имена.стек_областей.push(Default::default());
            for утверждение in &блок {
                скомпилировать_утверждение(пп, имена, &скомп_процедура, &mut локальные_имена, утверждение, &mut отложенные_возвраты)?;
            }
            let размер_области = локальные_имена
                .стек_областей
                .pop()
                .expect("Тело процедуры не трогает область которую мы протолкнули")
                .размер_переменных_на_стеке;
            if размер_области > 0 {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_области as u64), лок: процедура.имя.лок.clone() });
            }

            let конец_процедуры = пп.код.len();
            for адрес in отложенные_возвраты {
                let инструкция = пп.код.get_mut(адрес).expect("отложенные возвраты из процедуры: некорретный адрес");
                assert!(инструкция.вид == ВидИнструкции::Прыжок(0), "отложенные возвраты из процедуры: некорректная инструкция: {:?}", инструкция.вид);
                инструкция.вид = ВидИнструкции::Прыжок(конец_процедуры);
            }
            if let Некий(результат) = &скомп_процедура.результат {
                пп.код.push(Инструкция{ вид: ВидИнструкции::Кадр(результат.смещение_от_кадра), лок: процедура.имя.лок.clone() });
                if результат.тип.примитивный() {
                    прочитать_примитивный_тип(&процедура.имя.лок, &mut пп.код, &имена.структуры, &результат.тип)?;
                    пп.код.push(Инструкция{ вид: ВидИнструкции::АргументСоСтека, лок: процедура.имя.лок.clone() });
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ВосстановитьКадр, лок: процедура.имя.лок.clone() });
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_параметров_на_стеке as u64), лок: процедура.имя.лок.clone() });
                } else {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::АргументСоСтека, лок: процедура.имя.лок.clone() });
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ВосстановитьКадр, лок: процедура.имя.лок.clone() });
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_параметров_на_стеке as u64 - результат.тип.размер(&имена.структуры) as u64), лок: процедура.имя.лок.clone() });
                }
            } else {
                пп.код.push(Инструкция{ вид: ВидИнструкции::АргументСоСтека, лок: процедура.имя.лок.clone() });
                пп.код.push(Инструкция{ вид: ВидИнструкции::ВосстановитьКадр, лок: процедура.имя.лок.clone() });
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_параметров_на_стеке as u64), лок: процедура.имя.лок.clone() });
            }
            пп.код.push(Инструкция{ вид: ВидИнструкции::Возврат, лок: процедура.имя.лок.clone() });
            Хорош(())
        }
        ТелоПроцедуры::Внешнее{символ} => {
            let индекс = пп.внешние_символы.len();
            let индекс = *пп.внешние_символы.entry(символ.текст).or_insert(индекс);
            let скомп_процедура = СкомпПроцедура{
                имя: процедура.имя,
                параметры,
                точка_входа: ТочкаВхода::Внешняя{индекс},
                результат,
            };
            if let Некий(_) = имена.процедуры.insert(скомп_процедура.имя.текст.clone(), скомп_процедура) {
                unreachable!("Проверка переопределения процедур должна происходить на этапе разбора")
            }
            Хорош(())
        }
    }
}

fn скомпилировать_константное_выражение(пп: &ПП, имена: &Имена, локальные_имена: Опция<&ЛокальныеИмена>, выражение: &Выражение) -> Результат<(Vec<u8>, Тип)> {
    let mut временный_размер = 0;
    let mut пп = (*пп).clone();
    пп.код.clear();
    пп.внешние_символы.clear();
    пп.библиотеки.clear();
    let текущая_процедура = СкомпПроцедура {
        имя: Лексема {
            вид: ВидЛексемы::Идент,
            текст: "<Констатное Выражение>".to_string(),
            лок: выражение.лок().clone(),
        },
        параметры: vec![],
        результат: Нету,
        точка_входа: ТочкаВхода::Внутреняя{адрес: 0},
    };
    let mut имена = имена.clone();
    имена.процедуры.clear();
    имена.переменные.clear();
    let mut локальные_имена = локальные_имена.cloned().unwrap_or_else(|| ЛокальныеИмена::default());
    for область in локальные_имена.стек_областей.iter_mut() {
        область.переменные.clear();
        область.размер_переменных_на_стеке = 0;
    }
    let тип = скомпилировать_выражение(&mut пп, &имена, &текущая_процедура, &локальные_имена, выражение, &mut временный_размер)?;
    if !тип.примитивный() {
        // СДЕЛАТЬ: Компиляция константных выражений сложных типов
        // Главная проблема здесь в том, что любое выделение
        // инициализированных данных при компиляции константного
        // выражения уходит во временную машину. Это особенно
        // проблемно для строковых литералов:
        //
        //     конст СООБЩЕНИЕ := «Привет, «Мир»!»;
        //
        //     про главная() нч
        //         печать(СООБЩЕНИЕ, «\н»);12
        //     кц
        //
        // Данная программа будет сегфолтиться, т.к. сообщения
        // «Привет, «Мир»!» в памяти главное машины не
        // существует. Адрес константы СООБЩЕНИЯ ссылается в никуда.

        диагностика!(выражение.лок(), "ОШИБКА", "На данный момент разрешена компиляция константных выражений только примитивных типов");
        return Ошиб(());
    }
    пп.код.push(Инструкция{ вид: ВидИнструкции::Возврат, лок: выражение.лок().clone() });
    let mut машина = Машина::новая(&пп, 1024);
    let _ = машина.интерпретировать(&имена, 0, false)?;
    let значение_или_адрес = машина.стек.pop().unwrap();
    assert!(машина.стек.len() == 1); // Содержит только адрес возврата
    if тип.примитивный() {
        return Хорош((значение_или_адрес.to_le_bytes().to_vec(), тип));
    } else {
        return Хорош((машина.срез_памяти(значение_или_адрес, тип.размер(&имена.структуры))?.to_vec(), тип));
    }
}

fn скомпилировать_тип(пп: &ПП, тип: &Выражение, имена: &Имена, локальные_имена: Опция<&ЛокальныеИмена>) -> Результат<Тип> {
    match тип {
        Выражение::Лог(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Логические выражения не являться типами");
            Ошиб(())
        }
        Выражение::ЦелЧисло(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Целое число не является являться типом");
            Ошиб(())
        }
        Выражение::НатЧисло(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Натуральное число не является являться типом");
            Ошиб(())
        }
        Выражение::ВещЧисло(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Вещественное число не является являться типом");
            Ошиб(())
        }
        Выражение::Строка(лексема) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Строка не является являться типом");
            Ошиб(())
        }
        Выражение::Идент(лексема) => match лексема.текст.as_str() {
            "цел" | "цел64" => Хорош(Тип::Цел64),
            "нат" | "нат64" => Хорош(Тип::Нат64),
            "нат8" => Хорош(Тип::Нат8),
            "вещ" | "вещ32" => Хорош(Тип::Вещ32),
            "строка" => Хорош(Тип::Срез { тип_элемента: Box::new(Тип::Нат8) }),
            "лог" => Хорош(Тип::Лог),
            _ => {
                if имена.структуры.contains_key(&лексема.текст) {
                    Хорош(Тип::Структура(лексема.текст.clone()))
                } else {
                    диагностика!(&лексема.лок, "ОШИБКА", "Неизвестный тип «{тип}»", тип = лексема.текст);
                    Ошиб(())
                }
            }
        }
        Выражение::ЦепочкаВызовов{имя, цепочка_аргументов} => {
            match &цепочка_аргументов.as_slice() {
                &[] => unreachable!("Цепочки вызовов всегда содержать хотя бы один набор аргументов"),
                &[аргументы] => {
                    match имя.текст.as_str() {
                        "массив" => {
                            let [выражение_размера, тип_элемента] = аргументы.выражения.as_slice() else {
                                let количество_параметров = 2;
                                let количество_аргументов = аргументы.выражения.len();
                                диагностика!(&имя.лок, "ОШИБКА",
                                             "Неверное количество аргументов параметризированного типа. Тип «{имя}» принимает {количество_параметров} {параметров}, но предоставлено лишь {количество_аргументов} {аргументов}.",
                                             имя = имя.текст,
                                             параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                             аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                                return Ошиб(())
                            };
                            let (байты_размера, тип_размера) = скомпилировать_константное_выражение(&пп, имена, локальные_имена, &выражение_размера)?;
                            проверить_типы(выражение_размера.лок(), &Тип::Цел64, &тип_размера)?;
                            let размер = usize::from_le_bytes(байты_размера.try_into().unwrap());
                            let тип_элемента = Box::new(скомпилировать_тип(пп, &тип_элемента, имена, локальные_имена)?);
                            Хорош(Тип::Массив{размер, тип_элемента})
                        }
                        "срез" => {
                            let [тип_элемента] = аргументы.выражения.as_slice() else {
                                let количество_параметров = 1;
                                let количество_аргументов = аргументы.выражения.len();
                                диагностика!(&имя.лок, "ОШИБКА",
                                             "Неверное количество аргументов параметризированного типа. Тип «{имя}» принимает {количество_параметров} {параметров}, но предоставлено лишь {количество_аргументов} {аргументов}.",
                                             имя = имя.текст,
                                             параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                             аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                                return Ошиб(())
                            };
                            let тип_элемента = Box::new(скомпилировать_тип(пп, &тип_элемента, имена, локальные_имена)?);
                            Хорош(Тип::Срез{тип_элемента})
                        }
                        _ => {
                            диагностика!(&имя.лок, "ОШИБКА", "Неизвестный параметризированный тип «{тип}»", тип = имя.текст);
                            Ошиб(())
                        }
                    }
                }
                _ => {
                    диагностика!(&имя.лок, "ОШИБКА", "Цепочки вызовов в контексте типов пока не имеют особого смысла.");
                    Ошиб(())
                }
            }
        }
        Выражение::Биноп{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Подобные бинарные операции не поддерживаются в типах");
            Ошиб(())
        }
        Выражение::УнарныйМинус{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Подобные унарные операции не поддерживаются в типах");
            Ошиб(())
        }
        Выражение::Отрицание{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Отрицание не поддерживается в типах");
            // Хотя, это довольно таки интересна идея. Тип «не цел». Любой тип, кроме целого...
            Ошиб(())
        }
    }
}

impl Программа {
    pub fn скомпилировать_лексемы(&mut self, лекс: &mut Лексер) -> Результат<()> {
        loop {
            let ключ = лекс.вытащить_лексему_вида(&[
                ВидЛексемы::КлючПер,
                ВидЛексемы::КлючПро,
                ВидЛексемы::КлючКонст,
                ВидЛексемы::КлючВкл,
                ВидЛексемы::КлючБибл,
                ВидЛексемы::КлючСтрукт,
                ВидЛексемы::Конец,
            ])?;
            match ключ.вид {
                ВидЛексемы::КлючПер => {
                    let синтаксис = Переменная::разобрать(лекс)?;
                    let имя = синтаксис.имя;
                    self.имена.верифицировать_переопределение_имени(&имя)?;
                    let тип = скомпилировать_тип(&self.пп, &синтаксис.тип, &self.имена, Нету)?;
                    let смещение = self.пп.размер_неиниц_данных as i32;
                    self.пп.размер_неиниц_данных += тип.размер(&self.имена.структуры);
                    if let Некий(_) = self.имена.переменные.insert(имя.текст.clone(), СкомпПеременная {имя, тип, смещение}) {
                        unreachable!("Проверка переопределения переменных должна происходить на этапе разбора")
                    }
                }
                ВидЛексемы::КлючПро => {
                    let процедура = Процедура::разобрать(лекс)?;
                    self.имена.верифицировать_переопределение_имени(&процедура.имя)?;
                    скомпилировать_процедуру(&mut self.пп, &mut self.имена, процедура)?;
                }
                ВидЛексемы::КлючКонст => {
                    let константа = Константа::разобрать(лекс)?;
                    self.имена.верифицировать_переопределение_имени(&константа.имя)?;
                    let (байты_значения, тип) = скомпилировать_константное_выражение(&self.пп, &self.имена, Нету, &константа.выражение)?;
                    if тип.примитивный() {
                        let значение = u64::from_le_bytes(байты_значения.try_into().unwrap());
                        if let Некий(_) = self.имена.константы.insert(константа.имя.текст.clone(), СкомпКонстанта {
                            имя: константа.имя.clone(),
                            тип,
                            значение_или_адрес: значение
                        }) {
                            unreachable!("Проверка переопределения констант должна происходить на этапе разбора")
                        }
                    } else {
                        let адрес = self.пп.иниц_данные.len();
                        self.пп.иниц_данные.extend(байты_значения);
                        if let Некий(_) = self.имена.константы.insert(константа.имя.текст.clone(), СкомпКонстанта {
                            имя: константа.имя.clone(),
                            тип,
                            значение_или_адрес: адрес as u64,
                        }) {
                            unreachable!("Проверка переопределения констант должна происходить на этапе разбора")
                        }
                    }
                }
                ВидЛексемы::КлючВкл => {
                    // СДЕЛАТЬ: расхардкодить пути поиска модулей
                    let пути_поиска_модулей = &[".", "./модули"];
                    // СДЕЛАТЬ: отслеживать повторное включение модулей и игнорировать его.
                    let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
                    let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
                    let mut существует = false;
                    for путь in пути_поиска_модулей {
                        let mut путь_к_файлу = PathBuf::new();
                        путь_к_файлу.push(путь);
                        путь_к_файлу.push(&имя.текст);
                        путь_к_файлу.set_extension("хуя");
                        if путь_к_файлу.exists() {
                            существует = true;
                            let содержимое = ::прочитать_содержимое_файла(&путь_к_файлу, Некий(имя.лок.clone()))?;
                            let mut лекс = Лексер::новый(&путь_к_файлу, &содержимое);
                            self.скомпилировать_лексемы(&mut лекс)?;
                            break;
                        }
                    }
                    if !существует {
                        диагностика!(имя.лок, "ОШИБКА", "Не удалось найти модуль «{имя}».", имя = имя.текст);
                        return Ошиб(());
                    }
                }
                ВидЛексемы::КлючБибл => {
                    let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
                    self.пп.библиотеки.insert(имя.текст.clone(), self.пп.библиотеки.len());
                    let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
                }
                ВидЛексемы::КлючСтрукт => {
                    let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
                    let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::КлючНч])?;
                    let mut поля: HashMap<String, Поле> = HashMap::new();
                    let mut размер = 0;
                    // СДЕЛАТЬ: однополевые структуры через ключ «то»
                    while лекс.подсмотреть_лексему()?.вид != ВидЛексемы::КлючКц {
                        let смещение = размер;
                        let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
                        let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::Двоеточие])?;
                        let тип = скомпилировать_тип(&self.пп, &Выражение::разобрать(лекс)?, &self.имена, Нету)?;
                        let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
                        размер += выравнять_размер_по_слову(тип.размер(&self.имена.структуры));
                        if let Некий(дубль) = поля.get(&имя.текст) {
                            диагностика!(&имя.лок, "ОШИБКА", "Поле «{имя}» уже существует", имя = имя.текст);
                            диагностика!(&дубль.имя.лок, "ИНФО", "Оно определено здесь");
                            return Ошиб(());
                        }
                        if let Некий(_) = поля.insert(имя.текст.clone(), Поле {имя, тип, смещение}) {
                            unreachable!();
                        }
                    }
                    let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::КлючКц])?;
                    if let Некий(дубль) = self.имена.структуры.get(&имя.текст) {
                        диагностика!(&имя.лок, "ОШИБКА", "Структура «{имя}» уже существует", имя = имя.текст);
                        диагностика!(&дубль.имя.лок, "ИНФО", "Она определено здесь");
                        return Ошиб(());
                    }
                    if let Некий(_) = self.имена.структуры.insert(имя.текст.clone(), Структура {имя, поля, размер}) {
                        unreachable!()
                    }
                }
                ВидЛексемы::Конец => break,
                _ => unreachable!(),
            }
        }

        Хорош(())
    }

    pub fn завершить_компиляцию(&mut self) {
        for (_, СкомпПеременная{смещение, ..}) in self.имена.переменные.iter_mut() {
            *смещение += self.пп.иниц_данные.len() as i32;
        }

        for индекс in &self.пп.заплатки_неиниц_указателей {
            if let Некий(Инструкция{ вид: ВидИнструкции::ГлобальныеДанные(указатель), .. }) = self.пп.код.get_mut(*индекс) {
                *указатель += self.пп.иниц_данные.len() as i32;
            } else {
                unreachable!("Ошибка в процессе сбора заплаток указателей на неинициализированные данные. Каждый индекс такой заплатки должен указывать на инструкцию ПротолкнутьУказатель");
            }
        }
    }
}
